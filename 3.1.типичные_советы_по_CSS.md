# Типичные советы по CSS


Здесь собираются типичные советы по CSS.


## Базовые критерии

### Б21

:red_circle: - Явно указывайте начальное и конечное значения для анимации в keyframes (критерий Б21).

:point_up: - Это упрощает понимание происходящего, когда анимаций становится действительно много и требуется отладка. Нет нужды ходить каждый раз, искать, где же анимация применяется, и высматривать там ее составляющие. А еще эти составляющие порой разные в разных компонентах оказываются, и от такой невнимательности может начинаться магия. Когда все в одном месте - думать проще, ошибок меньше.


## Ситуативные советы

### Про производительность transform

:point_up: - С точки зрения производительности лучше отдавать предпочтение свойству `transform`. Более подробно тема производительности в CSS разбирается во втором модуле учебника, но если в двух словах, то лучше все, что есть, анимировать меняя свойства `transform` и `opacity`, т.к. они менее склонны вызывать перерисовку всей страницы. Не всегда решение очевидно с первого взгляда, но это вопросы больше из области верстки, а не анимаций.

:heavy_plus_sign: - Может быть полезно завести себе в привычку сразу верстать разные состояния компонентов интерфейса так, чтобы они отличались только по этим свойствам, или по крайней мере стремиться к этому. Это простой способ предотвратить рост технического долга по части производительности в нашем текущем контексте. Главный подводный камень тут в том, что проблемы с производительностью, заложенные в таких анимациях, имеют накопительный эффект. Чем больше одновременных анимаций и чем больше страница - тем сильнее они будут проявляться. И не всегда можно заранее предсказать, где те или иные компоненты будут использоваться. В результате может получиться пожар из разряда тех, что проще предотвратить, чем потушить. Думаю вы видели такие интернет-магазины, которые чуть ли не вешаются при открывании какой-нибудь менюшки - это именно оно. Схожий эффект может дать постоянное залезание в DOM из скриптов и совершение операций, которые вызывают перерисовку страницы в той или иной степени. Там тоже легко закрыть на это глаза на простой странице, но по мере роста проекта проблемы с производительностью будут усугубляться аналогичным образом. В некоторых особо сложных случаях делу может помочь свойство `contain`, но оно не решает проблему с перерисовкой страницы полностью, оно лишь помогает ее локализовать. Иногда этого достаточно, чтобы страница перестала тормозить, иногда - нет.


### Про REM

:point_up: - Весь макет сверстан в единицах rem, которые привязаны к размеру экрана. Фиксированные значения в px могут разойтись с ними и привести к багам или странным движениям на определенных размерах экрана. Лучше продолжать использовать rem. Если все же нужны пиксели, то стоит все проверять много раз на всех возможных размерах экранов - такие нестыковки легко пропустить.

:heavy_plus_sign: - Если вы раньше не сталкивались с версткой на плавающих размерах шрифта и с CSS-шлюзами, то будет полезно познакомиться с [хорошей статьей](https://www.smashingmagazine.com/2016/05/fluid-typography/) по теме.


### Про глаголы в названиях действий

:point_up: - Будет хорошей идеей использовать глаголы в названиях анимаций, чтобы подчеркнуть действия, которые в них происходят (мы то же самое делаем в скриптах для функций). Это очень поможет с восприятием кода, когда анимаций станет на самом деле много.


### Про fadeIn, fadeOut и.т.д.

:point_up: - Для таких анимаций есть общепринятые названия вроде fadeIn, fadeOut, fadeInLeft, fadeInRight и.т.д. Есть популярная библиотека [animate.css](https://animate.style/) в которой они все собраны. Если вы будете придерживаться этих названий - ваш код будет проще понимать вашим коллегам, не нужно будет думать, что делает та или иная анимация.

:point_up: - Анимации вроде fadeIn, fadeOut, fadeInLeft и.т.д. - универсальные, их можно переиспользовать с разными элементами. Они логически не привязаны к какому-то конкретному элементу. Обычно такие анимации выносят в отдельный файл. Это упрощает поддержку кода - мы сразу знаем, где они лежат, и не дублируем их по всему проекту.


### Про туда-сюда

:point_up: - Для решения задачи анимирования "туда-сюда" можно использовать кривую Безье, которая немного выходит за пределы квадрата 1 на 1. Современные браузеры уже давно умеют такое делать. Как пример - [cubic-bezier.com/#.6,-0.25,.34,1.51](https://cubic-bezier.com/#.6,-0.25,.34,1.51).


### Про длинные строки

:point_up: - Такого рода длинные строки можно разбивать на несколько, и форматировать так, чтобы одинаковые сущности были ровно друг над другом. В большинстве случаев так будет проще бегло читать код. Не во всех проектах людьми приветствуются "лишние" пробелы, там есть разные аргументы по этому поводу, но если вы вообще никогда не пробовали так делать - то можно попробовать в этом проекте.


### Про color и конкретный цвет

:point_up: - В реальных сайтах часто бывает много цветов, может быть больше одной цветовой схемы, и идея с именованием color = конкретный цвет в контексте появления текста из прозрачности обычно работает не очень. Она быстро превращается в fadeInColor1, fadeInColor2, fadeInAccentColor, fadeInAccentColor2InDarkColorScheme и.т.д. Там могут быть десятки анимаций, почти одинаковых, но не совсем. Часто более удобным для поддержки решением будет использование одного fadeIn, никак не завязанного на цвет, для всего, пусть и ценой добавления оберток для текстов в некоторых элементах интерфейса.


### Про анимации в контексте страницы

:point_up: - При работе с CSS анимациями важно следить за тем, чтобы они не ломали верстку вокруг себя. Анимации на одних элементах могут смещать другие, провоцировать появление скроллбаров от переполнения чего-то, давать изменения в размерах элементов в 1px (артефакты округления), которые заметно портят общее впечатление от интерфейса, могут просто скрывать за собой другие анимации или перебивать их стили, и.т.д. Помните о том, что анимации существуют не в вакууме, и всегда проверяйте, что они работают нормально после внедрения в реальный интерфейс.


## Советы, закрепленные за конкретными заданиями

### :lock: 1.01 (про анимации в отдельном файле и анализ)

:heavy_plus_sign: - В рамках курса у нас есть второй проект - "Иллюзион". Там практически весь код, связанный с CSS-анимациями [вынесен в отдельный файл](https://github.com/htmlacademy-animation/illusion/blob/master/source/sass/animation.scss). Альтернативно можно было бы этот код поделить и хранить в файлах самих компонентов, к которым он относится. Предлагаю вам подумать, какой из этих двух вариантов организации кода будет удобнее и, главное, почему? Не воспринимайте "эталонные" примеры как нечто единственно правильное. Возможны разные варианты. Раскритикуйте код Иллюзиона по полной программе и придумайте аргументы "за" и "против" предложенного там подхода.

:heavy_plus_sign: - По мере прохождения курса мы будем затрагивать разные подходы к разным задачам, иногда будем слегка противоречить учебнику или дополнять его, и будет хорошо, если вы уже сейчас начнете заниматься анализом того, что вы делаете. Почему что-то сделано так, а не иначе? Почему выбран именно такой инструмент? А какие еще есть варианты? Почему не вон тот инструмент? Почему? Почему? Почему? Анализируя контекст вы не только будете глубже разбираться в том, что делаете, но и будете развивать способность к аргументации собственных профессиональных решений. Очень полезная штука. А я буду время от времени вас подталкивать к размышлениям, задавая какие-то вопросы или делая отсылки к альтернативным инструментам. В идеальном варианте к концу курса мы сможем сформировать у вас разностороннее видение предметной области, чтобы вы не просто слепо повторяли "единственно правильные решения", а все же понимали, что вы делаете, и зачем. Но придется много думать, без этого никак.


### :lock: 1.02 (про константы в дизайн-системе)

:heavy_plus_sign: - Если у нас в проекте есть дизайн-система, то вполне вероятно, что она включает в себя набор длительностей и временных функций для анимаций, [вроде такого](https://m3.material.io/styles/motion/easing-and-duration/applying-easing-and-duration). К сожалению в учебном проекте такой системы нет, но тем не менее у вас в коде будут продолжать накапливаться повторяющиеся значения длительностей, задержек для анимаций и временных функций. И на самом деле в любом проекте они будут накапливаться. Может иметь смысл подумать над тем, как будет удобно организовать эти повторяющиеся значения в набор констант препроцессора. Какие можно придумать варианты именования, насколько большие или маленькие наборы можно делать, как их удобно расширять и.т.д. В рамках вашего личного проекта никто не запретит вам попробовать разные варианты, и посмотреть, что получится. С выразительным кодом без магических чисел всегда проще работается в долгосрочной перспективе, и даже если системы изначально нет в дизайне, никто не мешает ее создать в коде. По крайней мере ее кусочек.


### :lock: 1.03 (про переходы между экранами, про Barba.js)

:heavy_plus_sign: - Поскольку задача сделать плавные переходы довольно распространенная, будет полезно подумать о том, как строится логика таких переходов. Возможно вы уже работали с какими-то роутерами и все видели, но если нет, то подумайте, какие логические состояния есть у компонента "экран"? Сколько их? 1? 2? 4? Больше? Переход между экранами - это событие? Или может быть это растянутый во времени процесс с событиями начала и конца? Можем ли мы быть уверены в длительности этого процесса? А если экраны - это буквально разные страницы, которые подгружаются в процессе? Как стоило бы организовать модуль, который переключает экраны, чтобы было удобно завязать на него все наши анимации как появления, так и исчезания компонентов интерфейса?

:heavy_plus_sign: - По теме плавных переходов между экранами будет полезно дополнительно познакомиться с библиотекой [Barba.js](https://barba.js.org/), если вы еще не знакомы. В учебном проекте все нужно делать без использования сторонних библиотек, но это популярный инструмент, про который стоит знать.


### :lock: 2.01 (про промышленный дизайн и видео-концепты)

:heavy_plus_sign: - Получение длительностей и угадывание временных функций из видео при работе над интерфейсами – в некоторой степени сомнительная затея. В рамках учебного курса, как упражнение - ок. Развиваем глазомер, так сказать. Но в реальной работе – не забывайте, что там, где есть детальный видео-концепт – есть и дизайнер с его исходниками. В исходниках все есть. Даже если мы попали в ситуацию отсутствия у нас нужного софта (например дизайнер с After Effects, а у нас линукс) – банальные скриншоты проекта, где будет видно, что происходит, сэкономят общее время при разработке. Если все же возникает желание/необходимость смотреть видео по кадрам, то это может быть куда удобнее делать в программах, предназначенных для редактирования видео. Если вы еще пользуетесь плеером на страницах учебника - попробуйте альтернативные варианты, не пожалеете. Там есть разные программы, сам я обычно использую [Blender](https://www.blender.org/), потому что он и так используется для работы с 3D, и получается все в одном месте.

:heavy_plus_sign: - Мы еще будем возвращаться к теме видео-концептов, но сейчас стоит сказать важную вещь: дизайн интерфейсов – это больше промышленный дизайн, чем искусство. Все должно быть по возможности унифицировано для уменьшения издержек на производстве. Если анимации имеют разную длительность – это должно быть логически обосновано. Если разные временные функции – тоже. Как рабочему в мастерской не придет в голову собирать стеллаж на 20 разных видах шурупов, так и нам не нужно плодить сущности без потребности. Система в голове, в дизайне, и в коде – один из доступных способов сделать работу комфортной, и уменьшить количество издержек, как технических, так и организационных. При налаживании процессов разработки очень часто мы будем попадать в ситуацию, когда есть дизайн-система (а если ее и нет, то мы ее можем создать), и все длительности и временные функции берутся из нее, а видео-концепты - это скорее способ показать смысл движений в общих чертах, но их не нужно рассматривать как эталон, к которому нужно что-то подгонять.


### :lock: 2.02 (про левые пробелы и выбор инструментов)

:heavy_plus_sign: - В таких скриптах в реальных проектах часто практичнее разбивать все регулярным выражением, а не вот так, особенно если контент делает кто-то "не в теме" и может воткнуть странные пробелы, табы, переносы строк, и.т.д.

:heavy_plus_sign: - В 99% подобных анимаций рандомные задержки, или какие-то еще рандомные штуки - рандомные. По логике своей. Их не нужно подбирать. Если у вас возникает мысль "а не подобрать ли мне сотню случайных значений из видео" - скорее всего этого делать не нужно. Часто гораздо быстрее и проще у дизайнера в чате спросить "а это по смыслу случайные штуки?", получить ответ "да", и воткнуть в нужное место Math.random() или что-то такое, но не подбирать такие значения. Может быть нужно будет ограничить максимальные и минимальные значения, или задать общее направление движения, если оно там есть, но не более того. Этого будет достаточно, чтобы сохранить характер анимации. Для общего развития по теме рандомизации всего и вся будет полезно загуглить про генераторы 1D, 2D и 3D шума. Идеи из них очень часто используются на подобных сайтах.

:heavy_plus_sign: - При работе с анимациями иногда приходится интегрировать свои анимации и какие-то сторонние инструменты. Учебник не особо раскрывает вопрос осознанного выбора инструментов, но мы будем понемногу эту тему затрагивать по мере прохождения курса, чтобы осмысливать происходящее с разных сторон. И первой мыслью для обдумывания будет то, что не все инструменты достаточно гибкие в нашем контексте. В случае с учебным проектом мы имеем такой инструмент, как Swiper. Модный слайдер, популярный выбор во многих компаниях. Но. Не всегда сторонние инструменты будут предполагать, что в них будут внедряться анимации с той или иной логикой работы. Например здесь в ТЗ мы сталкиваемся с тем, что нам по идее нужно сделать анимации текстов на слайдах истории, как появления (вы это уже делали в первом задании), так и исчезания (это нужно к защите). В видео-концепте видно какие там примерно длительности и размах движений. Но если мы попытаемся внедрить именно такие анимации исчезания текстов в Swiper - нас ждет разочарование. Мягко говоря. Это на удивление сложно сделать, хотя по сути смещение элемента в сторону - элементарная вещь. Это тот самый случай, когда написать свой слайдер быстрее, чем внедрить анимации в имеющийся. Это возможно, но крайне неудобно. Отсюда можно вынести мораль: нужно думать при выборе инструментов, и выбирать инструменты, подходящие под задачи. Часто популярные инструменты, которые хороши из коробки, плохо кастомизируются. Это нужно иметь в виду, и заранее анализировать, насколько инструмент подходит или не подходит. Популярность не означает, что инструмент подойдет под конкретные задачи. В этом курсе инструменты выбраны за вас (иногда выбор спорный, к этому еще будем возвращаться), но в реальных проектах - выбирайте сами и с умом. Эти решения порой сложно отменить в будущем, а из-за одного странного выбора работа может сильно усложниться на ровном месте.


### :lock: 2.03 (про Locomotive Scroll, длину окружности, процессы разработки)

:heavy_plus_sign: - По теме CSS-анимаций будет полезно дополнительно познакомиться с библиотекой [Locomotive Scroll](https://locomotivemtl.github.io/locomotive-scroll/), если вы еще не знакомы. В учебном проекте все нужно делать без использования сторонних библиотек (да и скролла тут нет), но это популярный инструмент, про который стоит знать.

:heavy_plus_sign: - Для общего развития может быть полезно освежить в памяти школьную геометрию (планиметрию) и физику (механику в первую очередь), если вы еще этого не сделали. В разных задачах про вкатывания, падения с отскоками и другие условно физически правильные движения не всегда получается угадать нужные комбинации смещений и поворотов, чтобы все выглядело естественно. И тогда эти знания приходят на помощь. В случае со скриптами мы можем буквально подставлять формулы из справочников в код и получать натуральные движения с человеко-понятными коэффициентами, а в случае с CSS - мы можем по крайней мере точно посчитать комбинации значений. Далеко ходить не нужно - вкатывание круглой кнопки. Здесь ее смещение и угол поворота непосредственно связаны через радиус и формулу длины дуги окружности, и можно точно подогнать одно под другое. Понятно, что в такой простой задаче и угадать значения можно, но не все задачи будут простыми. Не обязательно погружаться в какие-то дебри и строгие доказательства теорем, но определенно имеет смысл полистать на досуге википедию или какой-нибудь справочник для поступающих в ВУЗы, чтобы иметь общее представление о том, что там бывает, и потом при случае не изобретать велосипеды, а воспользоваться готовыми знаниями.

:heavy_plus_sign: - И в завершение части курса про CSS, будет хорошо поднять тему последовательности разработки проекта. Вы идете по условным темам CSS/SVG/canvas/WebGL, которые поставили по возрастанию сложности. Но в реальной работе если начать с верстки, а WebGL оставить на конец – мы можем с разбега влететь в большие неприятности. Дело в том, что есть задачи, которые мы можем решить со 100% вероятностью в разумные сроки. CSS-анимации из их числа. Такие задачи даже можно переделегировать менее опытным коллегам в случае нехватки времени. А есть вещи, которые мы вообще не можем решить в технической плоскости. Только в организационной. Не потому, что мы глупые или чего-то не знаем, а потому, что мы работаем в реальном мире, и у пользователей просто может не быть железа, которое вытянет графику того уровня, которую заложили в концепт сайта. И если это обнаруживается в самом конце, перед дедлайном – проект загорится. Если же мы сначала попробовали сделать прототип самой подозрительной в этом плане части, и увидели проблемы, то у нас есть еще дни, а может и недели, чтобы переделать 3D-модели, поменять в каких-то пределах концепцию сайта или сами технологии (отказаться от рендеринга 3D в реальном времени в пользу каких-то других решений например). А уж верстку мы потом доделаем, это не вопрос. В идеальной ситуации мы должны консультировать дизайнеров по вопросам реалистичности концептов еще до их согласования, но, понятное дело, что тут нужен опыт, который появится не сразу. Мы еще будем возвращаться к этому вопросу по мере прохождения курса, а пока – подумайте над тем, что иногда разумнее сначала организовать какие-то процессы, а уже потом писать код. В следующем модуле это может быть важно.

