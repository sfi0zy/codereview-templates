# Типичные советы по CSS


Здесь собираются типичные советы по CSS.


## Ситуативные советы


### Про fadeIn, fadeOut и.т.д.

:point_up: - Для таких анимаций есть общепринятые названия вроде fadeIn, fadeOut, fadeInLeft, fadeInRight и.т.д. Есть популярная библиотека [animate.css](https://animate.style/) в которой они все собраны. Если вы будете придерживаться этих названий - ваш код будет проще понимать вашим коллегам, не нужно будет думать, что делает та или иная анимация.

:point_up: - Анимации вроде fadeIn, fadeOut, fadeInLeft и.т.д. - универсальные, их можно переиспользовать с разными элементами. Они логически не привязаны к какому-то конкретному элементу. Обычно такие анимации выносят в отдельный файл. Это упрощает поддержку кода - мы сразу знаем, где они лежат, и не дублируем их по всему проекту.


### Про REM

:point_up: - Весь макет сверстан в единицах rem, которые привязаны к размеру экрана. Фиксированные значения в px могут разойтись с ними и привести к багам или странным движениям на определенных размерах экрана. Лучше продолжать использовать rem.

:heavy_plus_sign: - Если вы раньше не сталкивались с версткой на плавающих размерах шрифта и с CSS-шлюзами, то будет полезно познакомиться с [хорошей статьей](https://www.smashingmagazine.com/2016/05/fluid-typography/) по теме.


### Про производительность transform

:point_up: - С точки зрения производительности лучше отдавать предпочтение свойству `transform`. Более подробно тема производительности в CSS разбирается во втором модуле учебника, но если в двух словах, то лучше все, что есть, анимировать меняя свойства `transform` и `opacity`. Не всегда решение очевидно с первого взгляда, но это вопросы больше из области верстки, а не анимаций.

:heavy_plus_sign: - Может быть полезно завести себе в привычку сразу верстать разные состояния компонентов интерфейса так, чтобы там менялись только эти свойства, или по крайней мере стремиться к этому. Главный подводный камень тут в том, что проблемы с производительностью, заложенные в таких анимациях, имеют накопительный эффект. Чем больше анимаций и чем больше страница - тем сильнее они будут проявляться. И не всегда можно заранее предсказать, где те или иные компоненты будут использоваться и в каких количествах. В результате может получиться пожар из разряда тех, что проще предотвратить, чем потушить.

:heavy_plus_sign: - Схожий эффект может дать постоянное залезание в DOM из скриптов и совершение операций, которые вызывают перерисовку страницы в той или иной степени. Там тоже легко закрыть на это глаза на простой странице, но по мере роста проекта проблемы с производительностью будут усугубляться.


### Про туда-сюда

:point_up: - Для решения задачи анимирования "туда-сюда" можно использовать кривую Безье, которая немного выходит за пределы квадрата 1 на 1. Современные браузеры уже умеют такое делать. Как пример - [cubic-bezier.com/#.6,-0.25,.34,1.51](https://cubic-bezier.com/#.6,-0.25,.34,1.51).

:point_up: - А еще стоит взять на вооружение тот факт, что в каждом фрейме можно задать свою timing-function. Это еще один путь к созданию плавных анимаций, [как в этом примере](https://codepen.io/sfi0zy/pen/ZNJWzx).


### Про константы в дизайн-системе

:point_up: - Повторяющиеся значения времени или кривых для анимаций можно вынести в константы (раз уж препроцессор уже есть, то почему бы не использовать его возможности). На практике часто в проектах будет дополнение к дизайн-системе, где будет список стандартных значений для анимаций - время для короткой, средней и длинной, кривые по умолчанию и.т.д.


### Про анимации в контексте страницы

:point_up: - При работе с CSS анимациями важно следить за тем, чтобы они не ломали верстку вокруг себя.


### Про глаголы в названиях действий

:point_up: - Будет хорошей идеей использовать глаголы в названиях анимаций, чтобы подчеркнуть действия, которые в них происходят (мы то же самое делаем в скриптах для функций). Это очень поможет с восприятием кода, когда анимаций станет на самом деле много.


## Советы, закрепленные за конкретными заданиями


### :lock: 1.03 (про переходы между экранами, про Barba.js)

:heavy_plus_sign: - Поскольку задача сделать плавные переходы довольно распространенная, будет полезно подумать о том, как строится логика таких переходов. Какие логические состояния есть у компонента "экран"? Сколько их? 1? 2? 4? Больше? Переход между экранами - это событие? Или может быть это растянутый во времени процесс с событиями начала и конца? Можем ли мы быть уверены в длительности этого процесса? А если экраны - это буквально разные страницы, которые подгружаются в процессе? Как стоило бы организовать модуль, который переключает экраны, чтобы было удобно завязать на него все наши анимации появления и исчезания компонентов интерфейса?

:heavy_plus_sign: - По теме плавных переходов между экранами будет полезно дополнительно познакомиться с библиотекой [Barba.js](https://barba.js.org/), если вы еще не знакомы. В учебном проекте все нужно делать без использования сторонних библиотек, но это популярный инструмент, про который стоит знать.


### :lock: 2.01 (про промышленный дизайн и рандом)

:heavy_plus_sign: - Получение длительностей и угадывание временных функций из видео при работе над интерфейсами – в некоторой степени сомнительная затея. В рамках учебного курса, как упражнение - ок. Но в реальной работе – не забывайте, что там, где есть детальный видео-концепт – есть и дизайнер с его исходниками. В исходниках все есть. Даже если мы попали в ситуацию отсутствия у нас нужного софта – банальные скриншоты проекта от дизайнера, где будет видно, что происходит, сэкономят общее время при разработке. Если все же возникает желание/необходимость смотреть видео по кадрам, то это может быть куда удобнее делать в программах, предназначенных для редактирования видео. Если вы еще пользуетесь плеером на страницах учебника - попробуйте альтернативные варианты, не пожалеете.

:heavy_plus_sign: - Не менее частая ситуация (в мире фриланса – 9 из 10 проектов по субъективным ощущениям) – дизайнер не будет уметь работать с софтом для анимаций, и мы будем попадать в ситуацию, когда нужно все делать самому. Максимум – будут текстовые описания анимаций. Это определенная свобода для самовыражения, но и ответственность тоже. Поэтому важно продолжать развивать в себе насмотренность, чтобы здраво оценивать свои собственные творения.

:heavy_plus_sign: - Ну и еще вещь, про которую определенно стоит помнить вне зависимости от обстоятельств: дизайн интерфейсов – это больше промышленный дизайн, чем искусство. Все должно быть по возможности унифицировано для уменьшения издержек на производстве. Если анимации имеют разную длительность – это должно быть логически обосновано. Если разные временные функции – тоже. Как рабочему в мастерской не придет в голову собирать стеллаж на 20 разных видах шурупов, так и нам не нужно плодить сущности без потребности. Система в голове, в дизайне, и в коде – один из доступных способов сделать работу комфортной, и уменьшить количество издержек, как технических, так и организационных. Ну и если рассматривать анимации как часть дизайн-системы, влияющей на узнаваемость бренда – это тоже важно.

:heavy_plus_sign: - Пожалуй единственная ситуация, когда рандомизация значений в анимациях действительно может оказаться к месту - это движения, которые по отдельности не имеют никакого практического смысла (идут всегда вместе), но при этом повторяются много много раз подряд. Например прелоадеры из кучи элементов, которые летают по кругу. В целом они показывают, что что-то происходит, но по отдельности каждый элемент мало о чем говорит. Легкое изменение длительностей анимаций каждого элемента может делать такие анимации более живыми, интересными, как [в этом примере](https://codepen.io/sfi0zy/pen/QpOyxL). Но даже там будет хорошей идеей подобрать сочетание длительностей, или хотя бы логику их получения, один раз, и потом все переиспользовать.


### :lock: 2.02 (про левые пробелы и выбор инструментов)

:heavy_plus_sign: - В таких скриптах в реальных проектах часто практичнее разбивать все регулярным выражением, а не через split, особенно если контент делает кто-то "не в теме" и может воткнуть странные пробелы, табы, переносы строк, и.т.д.

:heavy_plus_sign: - При работе с анимациями иногда приходится внедрять анимации в какие-то сторонние инструменты. В случае с учебным проектом - это Swiper. Модный слайдер, популярный выбор во многих компаниях. Но. Не всегда сторонние инструменты будут предполагать, что в них будут внедряться анимации с той или иной логикой работы. Например здесь в ТЗ мы сталкиваемся с тем, что нам по идее нужно сделать анимации и появления, и исчезания текстов на слайдах истории (не в этом задании, а вообще). В видео-концепте видно какие там примерно длительности и размах движений по горизонтали. Но если мы попытаемся внедрить именно такие анимации в Swiper - нас ждет разочарование. Мягко говоря. Это очень сложно. Swiper не предполагает, что в него такое будут впихивать. Это тот самый случай, когда написать свой слайдер быстрее, чем внедрить анимации в имеющийся. Отсюда можно вынести мораль: нужно думать при выборе инструментов, и выбирать инструменты, подходящие под задачи. Часто большие и популярные инструменты плохо кастомизируются, это нужно иметь в виду, и заранее анализировать, насколько инструмент подходит или не подходит. Популярность не означает, что инструмент подойдет под конкретные задачи.


### :lock: 2.03 (про Locomotive Scroll, длину окружности, процессы разработки)

:heavy_plus_sign: - По теме CSS-анимаций будет полезно дополнительно познакомиться с библиотекой [Locomotive Scroll](https://locomotivemtl.github.io/locomotive-scroll/), если вы еще не знакомы. В учебном проекте все нужно делать без использования сторонних библиотек, но это популярный инструмент, про который стоит знать.

:heavy_plus_sign: - Для общего развития может быть полезно освежить в памяти школьную геометрию и физику (механику в первую очередь), если вы еще этого не сделали. В разных задачах про вкатывания, падения с отскоками и другие условно физически правильные движения не всегда получается угадать нужные комбинации смещений и поворотов, чтобы все выглядело естественно. И тогда эти знания приходят на помощь. В случае со скриптами мы можем буквально подставлять формулы из справочников в код и получать натуральные движения с человеко-понятными коэффициентами, а в случае с CSS - мы можем по крайней мере точно посчитать комбинации значений. Например вкатывание круглой кнопки - здесь ее смещение и угол поворота непосредственно связаны через радиус и формулу длины дуги окружности, и можно точно подогнать одно под другое. Понятно, что в такой простой задаче и угадать значения можно, но не все задачи будут простыми.

:heavy_plus_sign: - У вас в учебнике затрагивается тема прогрессивного улучшения и деградации. Но тут стоит отметить, что в контексте разработки рекламных сайтов, или просто каких-то штук, где много всего происходит в визуальном плане, сами процессы разработки не стоит завязывать на эти понятия. Если начать с верстки, а WebGL оставить на конец – мы можем с разбега влететь в большие неприятности. Дело в том, что есть задачи, которые мы можем решить со 100% вероятностью в разумные сроки. CSS-анимации из их числа. Такие задачи даже можно переделегировать менее опытным коллегам в случае нехватки времени. А есть вещи, которые мы вообще не можем решить в технической плоскости. Только в организационной. Не потому, что мы глупые или чего-то не знаем, а потому, что мы работаем в реальном мире, и у пользователей просто может не быть железа, которое вытянет графику того уровня, которую заложили в концепт сайта. И если это обнаруживается в самом конце, перед дедлайном – будет аврал. Заказчик будет сильно недоволен. Если же мы сначала попробовали сделать прототип самой подозрительной в этом плане части, и увидели проблемы, то у нас есть еще дни, а может и недели, чтобы переделать 3D-модели, поменять в каких-то пределах концепцию сайта или сами технологии (отказаться от рендеринга 3D в реальном времени в пользу каких-то других решений например). А уж верстку мы потом доделаем, это не вопрос. В идеальной ситуации мы должны консультировать дизайнеров по вопросам реалистичности концептов еще до их согласования, но, понятное дело, что тут нужен опыт, который появится не сразу. Мы еще будем возвращаться к этому вопросу по мере прохождения курса, а пока – подумайте над тем, что иногда разумнее сначала организовать какие-то процессы, а уже потом решать технические задачи.

