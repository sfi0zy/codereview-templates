# Типичные советы по WebGL

Здесь собираются типичные советы по WebGL. Нумерация - в порядке появления. В начале совета - палец. Советы дополняют ревью, но не являются основанием для отправки задания на доработку, если все работает так, как и должно. Это делается, чтобы не сильно демотивировать студентов - ошибки, описываемые здесь, можно поправить позже (особенно если студент приходит к одному наставнику и есть возможность следить за процессом). Про соответствие базовым критериям см. `4.базовые_критерии`.


### №1

:point_up: - Стандартные инструменты разработчика, например FPS-meter в Chrome, могут сильно привирать при работе с канвасом. По их показаниям может казаться, что все хорошо, но глазами видно, что это не так. Или наоборот - все работает хорошо, а инструмент говорит, что все плохо. Здесь все так же, как и с PageSpeed Insights, если вы понимаете, о чем я. В качестве альтернативы можно сделать какое-нибудь свое решение или взять [stats.js](https://github.com/mrdoob/stats.js/). Кажется, что это самый популярный инструмент для этого среди разработчиков, связанных с Three.js.

:point_up: - У вас в критерии Б1 говорится, что анимация должна быть сделана без сторонних библиотек, но здесь речь именно про отладку, это можно потом убрать перед защитой.


### №2

:point_up: - Написание шейдеров в шаблонных строках - решение не самое удобное. В первую очередь из-за потери подсветки синтаксиса и смешения всего в одну кучу. Альтернативно можно хранить код шейдеров в HTML, как в [этом примере](https://codepen.io/sfi0zy/pen/dyMwreR). Это может быть неплохим вариантом для небольших демок или еще чего-то, что должно работать без системы сборки. Но самый универсальный подход - хранить код шейдеров в отдельных файлах и подставлять их содержимое в JS-скрипты при сборке с помощью плагинов для webpack или других сборщиков - там много вариантов на любой вкус и цвет.


### №3

:point_up: - Для расширения кругозора можно познакомиться с еще одним решением этой задачи: если нужно сгенерировать текстуру и при этом воспользоваться стандартными свойствами материалов из Three.js (тени, блики и.т.д.), то можно все нарисовать на отдельном канвасе и использовать его как текстуру. А еще так можно выводить видео на поверхность модели.


### №4

:point_up: - Задание называется "оптимизация под мобильные устройства"... Вообще подобные "оптимизации" действительно в теории дают какой-то прирост производительности, но на практике для пользователя разницы никакой - оно как тормозило, так и тормозит. И, разумеется, у нас здесь не игровая индустрия, мы не можем задать минимальные системные требования для сайта. Подобные оптимизации обычно имеют смысл только при доведении до идеала того, что и так работает хорошо. Отчасти по этой причине мне кажется хорошей идеей подобные проекты делать всегда в обратную сторону - начинать с прототипа трехмерной части, смотреть, насколько она работоспособной получается, и уже потом, если все ок, верстать все остальное. Ну а если не ок, то это обнаруживается сразу, а не перед дедлайном, и есть возможность поменять концепцию, заменить 3D на видео, или вообще от него отказаться в пользу каких-то 2D-эффектов в том же стиле. Не стоит надеяться на то, что любую сцену можно сделать производительной или что получится оптимизировать то, что явно тормозит, при этом сохранив изначальную концепцию и более-менее красивую картинку.

