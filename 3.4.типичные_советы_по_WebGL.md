# Типичные советы по WebGL

Здесь собираются типичные советы по WebGL. Нумерация - в порядке появления. В начале совета - палец. Советы дополняют ревью, но не являются основанием для отправки задания на доработку, если все работает так, как и должно. Это делается, чтобы не сильно демотивировать студентов - ошибки, описываемые здесь, можно поправить позже (особенно если студент приходит к одному наставнику и есть возможность следить за процессом). Про соответствие базовым критериям см. `4.базовые_критерии`.


### №1 (про отладку и FPS)

:point_up: - Стандартные инструменты разработчика, например FPS-meter в Chrome, могут сильно привирать при работе с канвасом. По их показаниям может казаться, что все хорошо, но глазами видно, что это не так. Или наоборот - все работает хорошо, а инструмент говорит, что все плохо. Здесь все так же, как и с PageSpeed Insights, если вы понимаете, о чем я. В качестве альтернативы можно сделать какое-нибудь свое решение или взять [stats.js](https://github.com/mrdoob/stats.js/). Кажется, что это самый популярный инструмент для этого среди разработчиков, связанных с Three.js.

:point_up: - У вас в критерии Б1 говорится, что анимация должна быть сделана без сторонних библиотек, но здесь речь именно про отладку, это можно потом убрать перед защитой.


### №2 (про шаблонные строки)

:point_up: - Написание шейдеров в шаблонных строках - решение не самое удобное. В первую очередь из-за потери подсветки синтаксиса и смешения всего в одну кучу. Альтернативно можно хранить код шейдеров в HTML, как в [этом примере](https://codepen.io/sfi0zy/pen/dyMwreR). Это может быть неплохим вариантом для небольших демок или еще чего-то, что должно работать без системы сборки. Но самый универсальный подход - хранить код шейдеров в отдельных файлах и подставлять их содержимое в JS-скрипты при сборке с помощью плагинов для webpack или других сборщиков - там много вариантов на любой вкус и цвет.


### №3 (про текстуры)

:point_up: - Для расширения кругозора можно познакомиться с еще одним решением этой задачи: если нужно сгенерировать текстуру и при этом воспользоваться стандартными свойствами материалов из Three.js (тени, блики и.т.д.), то можно все нарисовать на отдельном канвасе и использовать его как текстуру. А еще так можно выводить видео на поверхность модели.


### №4 (про оптимизацию для телефонов)

:point_up: - Задание называется "оптимизация под мобильные устройства"... Вообще подобные "оптимизации" действительно в теории дают какой-то прирост производительности, но на практике для пользователя разницы никакой - оно как тормозило, так и тормозит. И, разумеется, у нас здесь не игровая индустрия, мы не можем задать минимальные системные требования для сайта. Подобные оптимизации обычно имеют смысл только при доведении до идеала того, что и так работает хорошо. Отчасти по этой причине мне кажется хорошей идеей подобные проекты делать всегда в обратную сторону - начинать с прототипа трехмерной части, смотреть, насколько она работоспособной получается, и уже потом, если все ок, верстать все остальное. Ну а если не ок, то это обнаруживается сразу, а не перед дедлайном, и есть возможность поменять концепцию, заменить 3D на видео, или вообще от него отказаться в пользу каких-то 2D-эффектов в том же стиле. Не стоит надеяться на то, что любую сцену можно сделать производительной или что получится оптимизировать то, что явно тормозит, при этом сохранив изначальную концепцию и более-менее красивую картинку.


### №5 (про постпроцессинг и баги буфера глубины)

[ СКРИНШОТ ПРОЕКТА СТУДЕНТА (АНАЛОГИЧНАЯ КАРТИНКА ДЛЯ ПРИМЕРА) ]

![](https://habrastorage.org/webt/3n/dj/lg/3ndjlgwnetjbrplvrzjoy1fbk8m.jpeg)

:point_up: - В данном случае проблема проявилась в последнем Хроме под линуксом с графикой UHD Graphics 605, хотя могла проявиться и где-нибудь еще, например в Safari.

:point_up: - WebGL опускает нас к более низкому уровню работы с железом, мы уже не находимся в привычной песочнице javascript, в которой от железа не зависит почти ничего. И у разных браузеров на разном железе могут быть разные ограничения, например на максимальный размер текстуры или карты теней. По-хорошему проекты с WebGL нужно тестировать не только в разных браузерах, но и на разном железе (хотя, конечно, бюджет не всегда это позволяет). Плюс библиотека Three.js, если уж мы ее используем, накладывает сверху свою логику, в которой тоже есть не самые очевидные wtf-моменты, например добавление постобработки меняет то, как основной рендерер работает с буфером глубины и может произойти то, что видно на скриншоте. В данном случае вопрос можно решить, если руками включить логарифмический буфер глубины у рендерера. Это даст минус к производительности, но плюс к надежности.


### №6 (про отладку света)

:point_up: - При отладке света на сцене может быть хорошей идеей сделать источники света разноцветными. Например один ядрено-зеленым, другой ядрено-розовым и.т.д. Это позволит лучше видеть световой рисунок на сцене и будет проще подобрать параметры для источников света.

:point_up: - Также на время разработки можно подключить OrbitControls, чтобы крутить сцену и видеть ее с разных сторон. Это может быть полезно и при отладке света, и при расстановке объектов на сцене.


### №7 (про одну камеру и одну сцену)

:point_up: - Имейте в виду, что в конечном счете все это будет одной 3D-сценой с одной камерой. При разработке может быть удобно иметь несколько камер, но потом все равно нужно будет все объединить.


### №8 (про SVG extrude)

:point_up: - Очевидно, что некоторые объекты поломались. Обратите внимание на направление замкнутых контуров в SVG, именно по нему определяется внутренняя часть контура для заливки цветом, или, как в нашем случае, для определения, где должны быть плоские грани объекта. Изменить направление контуров в SVG можно в любом векторном графическом редакторе. Также у метода toShapes у ShapePath в Three.js есть параметр, которым можно изменить прямое и обратное направления кривых (по крайней мере их интерпретацию в рамках текущей задачи).


### №9 (про RGB, HSL, HSB)

:point_up: - Для общего развития полезно познакомиться также с разными цветовыми моделями, узнать разницу между RGB, HSL и HSB, и добавить в свой инструментарий функции конвертации цвета из одной в другую. В генеративной графике с яркими чистыми цветами часто гораздо удобнее все делать в HS\* и только в конце конвертировать цвета в RGB для вывода на экран.


### №10 (про хардкод)

:point_up: - Строго говоря эта анимация полностью генеративная, здесь никакие параметры извне не нужны и все можно захардкодить прямо в шейдере. В реальном мире не надуманных заданий такой грубый подход позволяет в разы сократить количество кода.


### №11 (про стандартные функции в GLSL)

:point_up: - Для таких вещей в GLSL предусмотрены стандартные математические функции. Полезно загуглить. Также в [этой статье](https://habr.com/ru/post/420847/) в начале есть спойлер с хорошими шпаргалками по теме.

:point_up: - Изобретение велосипедов - это полезно, но в работе использование стандартных, встроенных в язык, инструментов будет предпочтительнее, т.к. все ваши коллеги привыкли к стандартным обозначениям. Плюс в видеокартах некоторые стандартные функции выполняются быстрее, т.к. там все заоптимизировано с самых низов выполнять именно операции, скрытые за фасадом этих самых стандартных функций (набор которых в контексте GLSL совершенно не случайный).


### №12 (про оптимизацию моделей)

:point_up: - В целях общего развития может быть полезно взять какой-нибудь 3D-редактор, например [Blender](https://www.blender.org/) (он бесплатный и кроссплатформенный), и посмотреть на то, как устроены сложные модели:

![](https://habrastorage.org/webt/kd/cr/_g/kdcr_gim0p3ttq3gfyc-2wetv1g.jpeg)

:watch: :point_up: - На примере самолета из курса можно посмотреть пример модели, которую в контексте фронтенда нужно бы отправить на доработку. Количество вершин здесь можно уменьшить на порядок, без какого-либо влияния на видимый результат. Например такая детализация окон нам в проекте точно не нужна - самолетик слишком маленький, чтобы что-то там разглядеть. По идее нам нужно стремиться к использованию low poly моделей и этот факт в требования нужно закладывать сразу, еще до создания моделей. И на этом моменте можно улучшить не только размеры модели (и скорость ее загрузки по сети), но и общую производительность, т.к. значительно снизятся требования для видеокарты. Мне встречались проекты, где только оптимизация моделей позволяла увеличить средний fps на сайте с 2-3 кадров до 30-40 на ноутбуке с обычной UHD Graphics.


### №13 (про процедурные текстуры)

:point_up: - Полезно познакомиться с альтернативным решением, не упомянутом в учебнике: у материалов есть [onBeforeCompile](https://threejs.org/docs/#api/en/materials/Material.onBeforeCompile), можно прямо перед компиляцией шейдеров для материалов их модифицировать, в частности интегрировать туда свои шейдерно-сгенерированные текстуры.


### №14 (про WebGL Fluid Simulation)

:point_up: - По теме шейдеров будет полезно дополнительно познакомиться с библиотекой [WebGL Fluid Simulation](https://paveldogreat.github.io/WebGL-Fluid-Simulation/), если вы еще не знакомы. В учебном проекте все нужно делать без использования сторонних библиотек, но для собственного развития - будет полезно.


### №15 (про советы при работе с Three.js)

:point_up: - Полезно положить себе в закладки какую-нибудь статью с типичными советами для работы с Three.js, [например эту](https://discoverthreejs.com/tips-and-tricks/), и иногда к ней возвращаться, осмысливая то, что там предлагается делать или не делать, особенно в вопросах производительности. Важно понимать, что чудес не бывает, но подобные советы все же могут помочь в некоторых ситуациях.

