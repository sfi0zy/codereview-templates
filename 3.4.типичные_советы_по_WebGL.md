# Типичные советы по WebGL

Здесь собираются типичные советы по WebGL. Нумерация - в порядке появления. В начале совета - палец. Советы дополняют ревью, но не являются основанием для отправки задания на доработку, если все работает так, как и должно. Это делается, чтобы не сильно демотивировать студентов - ошибки, описываемые здесь, можно поправить позже (особенно если студент приходит к одному наставнику и есть возможность следить за процессом). Про соответствие базовым критериям см. `4.базовые_критерии`.


### №1 (про отладку и FPS)

:heavy_plus_sign: - В проекте постепенно накапливаются вопросы по части производительности. Будет полезно узнать, что стандартные инструменты разработчика, например FPS-meter в Chrome, могут сильно привирать при работе с канвасом. По их показаниям может казаться, что все хорошо, но глазами видно, что это не так. Или наоборот - все работает хорошо, а инструмент говорит, что все плохо. Здесь все так же, как и с PageSpeed Insights, если вы понимаете, о чем я. В основном причины этого кроются в том, что у нас из браузера не так много (фактически вообще нет) возможностей получать полную и достоверную информацию о происходящем на видеокарте. В качестве альтернативы FPS-meter можно сделать какое-нибудь свое решение или взять [stats.js](https://github.com/mrdoob/stats.js/). Кажется, что это самый популярный инструмент для отображения FPS среди разработчиков, связанных с Three.js.

:point_up: - У вас в критерии Б1 говорится, что анимация должна быть сделана без сторонних библиотек, но здесь речь именно про отладку, это можно потом убрать перед защитой.


### №2 (про шаблонные строки)

:heavy_plus_sign: - Написание шейдеров в шаблонных строках - решение не самое удобное. В первую очередь из-за потери подсветки синтаксиса и смешения всего в одну кучу. Альтернативно можно хранить код шейдеров в HTML, как в [этом примере](https://codepen.io/sfi0zy/pen/dyMwreR). Это может быть неплохим вариантом для небольших демок или еще чего-то, что должно работать без системы сборки. Но самый универсальный подход - хранить код шейдеров в отдельных файлах и подставлять их содержимое в JS-скрипты при сборке с помощью плагинов для webpack или других сборщиков - там много вариантов на любой вкус и цвет.


### №3 (про текстуры)

:heavy_plus_sign: - Для расширения кругозора можно познакомиться с еще одним решением этой задачи: если нужно сгенерировать текстуру и при этом воспользоваться стандартными свойствами материалов из Three.js (тени, блики и.т.д.), и если текстуру сложно сообразить в рамках одного шейдера, то можно все нарисовать на отдельном канвасе, в том числе на 2D, и использовать его как текстуру, [например как в этой демонстрации](https://codepen.io/sfi0zy/pen/NQOdGd). А еще так можно выводить видео на поверхность модели. А в теории можно и результат, полученный после выполнений шейдеров, сохранять и переиспользовать в других шейдерах, или даже в тех же самых. Но к этому мы еще вернемся в будущем. Важно понять идею, что текстура - это понятие очень растяжимое, по сути это картинка, а картинки можно переиспользовать в самых разных комбинациях.


### №4 (про оптимизацию для телефонов)

:heavy_plus_sign: - Вообще подобные "оптимизации" при работе с WebGL действительно в теории дают какой-то прирост производительности, но на практике для пользователя часто разницы никакой - оно как тормозило, так и тормозит. И, разумеется, у нас здесь не игровая индустрия, мы не можем задать минимальные системные требования для сайта. Подобные оптимизации обычно имеют смысл только при доведении до идеала того, что и так работает хорошо. Отчасти по этой причине мне кажется хорошей идеей подобные проекты делать всегда в обратную сторону - начинать с прототипа трехмерной части, смотреть, насколько она работоспособной получается, и уже потом, если все ок, верстать все остальное. Ну а если не ок, то это обнаруживается сразу, а не перед дедлайном, и есть возможность поменять концепцию, заменить 3D на видео, или вообще от него отказаться в пользу каких-то 2D-эффектов в том же стиле. Не стоит надеяться на то, что любую сцену можно сделать производительной или что получится оптимизировать то, что явно тормозит, при этом сохранив изначальную концепцию и более-менее красивую картинку.


### №5 (про постпроцессинг и баги буфера глубины)

[ СКРИНШОТ ПРОЕКТА СТУДЕНТА (АНАЛОГИЧНАЯ КАРТИНКА ДЛЯ ПРИМЕРА) ]

![](https://habrastorage.org/webt/3n/dj/lg/3ndjlgwnetjbrplvrzjoy1fbk8m.jpeg)

:point_up: - В данном случае проблема проявилась в последнем Хроме под линуксом с графикой UHD Graphics 605, хотя могла проявиться и где-нибудь еще, например в Safari.

:point_up: - WebGL опускает нас к более низкому уровню работы с железом, мы уже не находимся в привычной песочнице javascript, в которой от железа не зависит почти ничего. И у разных браузеров на разном железе могут быть разные ограничения, например на максимальный размер текстуры или карты теней. По-хорошему проекты с WebGL нужно тестировать не только в разных браузерах, но и на разном железе (хотя, конечно, бюджет не всегда это позволяет). Плюс библиотека Three.js, если уж мы ее используем, накладывает сверху свою логику, в которой тоже есть не самые очевидные wtf-моменты, например добавление постобработки меняет то, как основной рендерер работает с буфером глубины и может произойти то, что видно на скриншоте. В данном случае вопрос можно решить, если руками включить логарифмический буфер глубины у рендерера. Это даст минус к производительности, но плюс к надежности.


### №6 (про отладку света)

:point_up: - При отладке света на сцене может быть хорошей идеей сделать источники света разноцветными. Например один ядрено-зеленым, другой ядрено-розовым и.т.д. Это позволит лучше видеть световой рисунок на сцене и будет проще подобрать параметры для источников света.

:point_up: - Также на время разработки можно подключить OrbitControls, чтобы крутить сцену и видеть ее с разных сторон. Это может быть полезно и при отладке света, и при расстановке объектов на сцене.


### №7 (про одну камеру и одну сцену)

:point_up: - Имейте в виду, что в конечном счете все это будет одной 3D-сценой с одной камерой. При разработке может быть удобно иметь несколько камер, но потом все равно нужно будет все объединить.


### №8 (про SVG extrude)

:point_up: - Очевидно, что некоторые объекты поломались. Обратите внимание на направление замкнутых контуров в SVG, именно по нему определяется внутренняя часть контура для заливки цветом, или, как в нашем случае, для определения, где должны быть плоские грани объекта. Изменить направление контуров в SVG можно в любом векторном графическом редакторе. Также у метода toShapes у ShapePath в Three.js есть параметр, которым можно изменить прямое и обратное направления кривых (по крайней мере их интерпретацию в рамках текущей задачи).


### №9 (про RGB, HSL, HSB)

:heavy_plus_sign: - Для общего развития полезно познакомиться также с разными цветовыми моделями, узнать разницу между RGB, HSL и HSB, и добавить в свой инструментарий функции конвертации цвета из одной в другую. В генеративной графике с яркими чистыми цветами часто гораздо удобнее все делать в HS\*, [как в этом примере](https://codepen.io/sfi0zy/pen/JjbjxgQ), и только в конце конвертировать цвета в RGB для вывода на экран.


### №10 (про хардкод)

:heavy_plus_sign: - Строго говоря эта анимация полностью генеративная, здесь никакие параметры извне не нужны и все можно захардкодить прямо в шейдере. В реальном мире не надуманных заданий такой грубый подход часто позволяет в разы сократить количество кода без каких-либо последствий. Часто можно оставить только время в качестве параметра, [например как здесь](https://codepen.io/sfi0zy/pen/ZEGovzm), и этого будет достаточно.


### №11 (про стандартные функции в GLSL)

:point_up: - Для таких вещей в GLSL предусмотрены стандартные математические функции. Полезно загуглить. Также в [этой статье](https://habr.com/ru/post/420847/) в начале есть спойлер с хорошими шпаргалками по теме.

:point_up: - Изобретение велосипедов - это полезно, но в работе использование стандартных, встроенных в язык, инструментов будет предпочтительнее, т.к. все ваши коллеги привыкли к стандартным обозначениям. Плюс в видеокартах некоторые стандартные функции выполняются быстрее, т.к. там все заоптимизировано с самых низов выполнять именно операции, скрытые за фасадом этих самых стандартных функций (набор которых в контексте GLSL совершенно не случайный).


### №12 (про оптимизацию моделей)

:heavy_plus_sign: - В целях общего развития может быть полезно взять какой-нибудь 3D-редактор, например [Blender](https://www.blender.org/) (он бесплатный и кроссплатформенный), и посмотреть на то, как устроены сложные модели:

![](https://habrastorage.org/webt/kd/cr/_g/kdcr_gim0p3ttq3gfyc-2wetv1g.jpeg)

:heavy_plus_sign: - На примере самолета из курса можно посмотреть пример модели, которую в контексте фронтенда нужно бы отправить на доработку. Количество вершин здесь можно уменьшить на порядок, без какого-либо влияния на видимый результат. Например такая детализация окон нам в проекте точно не нужна - самолетик слишком маленький, чтобы что-то там разглядеть. По идее нам нужно стремиться к использованию low poly моделей и этот факт в требования нужно закладывать сразу, еще до создания моделей. И на этом моменте можно улучшить не только размеры модели (и скорость ее загрузки по сети), но и общую производительность, т.к. значительно снизятся требования для видеокарты. Мне встречались проекты, где только оптимизация моделей позволяла увеличить средний fps на сайте с 2-3 кадров до 30-40 на ноутбуке с обычной UHD Graphics.


### №13 (про процедурные текстуры)

:heavy_plus_sign: - Полезно познакомиться с альтернативным решением, не упомянутом в учебнике: у материалов есть [onBeforeCompile](https://threejs.org/docs/#api/en/materials/Material.onBeforeCompile), можно прямо перед компиляцией шейдеров для материалов их модифицировать, в частности интегрировать туда свои шейдерно-сгенерированные текстуры, [например вот так](https://codepen.io/sfi0zy/pen/XWerBEM).


### №14 (про WebGL Fluid Simulation)

:heavy_plus_sign: - По теме шейдеров будет полезно дополнительно познакомиться с библиотекой [WebGL Fluid Simulation](https://paveldogreat.github.io/WebGL-Fluid-Simulation/), если вы еще не знакомы. В учебном проекте все нужно делать без использования сторонних библиотек, но это популярный инструмент, про который стоит знать.


### №15 (про советы при работе с Three.js)

:heavy_plus_sign: - Полезно положить себе в закладки какую-нибудь статью с типичными советами для работы с Three.js, [например эту](https://discoverthreejs.com/tips-and-tricks/), и иногда к ней возвращаться, осмысливая то, что там предлагается делать или не делать, особенно в вопросах производительности. Важно понимать, что чудес не бывает, но подобные советы все же могут помочь в некоторых ситуациях.


### №16 (про тени и компьютерную графику)

:heavy_plus_sign: - Полезно при изучении разных штук в рамках Three.js обращать внимание и на то, что скрыто внутри них. Это – библиотека, набор готовых решений каких-то задач из мира компьтерной графики, и хорошо знать, что там происходит внутри. Не только для общего развития кругозора, но и для понимания, что и почему может повлиять на производительность, куда смотреть, если на экране появляются какие-то артефакты и.т.д. Например понимание алгоритмов, как рассчитываются тени от точечных источников света, может дать ответы на вопросы о том, почему много источников света с тенями – это беда для телефонов и встроенных видеокарт, или почему границы теней вдруг пошли квадратиками. Все это выходит за границы курса, но если вы хотите погрузиться в саму предметную область и решать задачи, выходящие за рамки примеров из документации – читайте больше статей и книг по компьютерной графике. Все, до чего руки доберутся. Конкретные инструменты меняются, но общие принципы формирования того же 2D изображения из 3D сохраняются десятки лет.


### №17 (про розовые очки)

:heavy_plus_sign: - К последнему заданию на курсе повторю мысли о суровой реальности: мы можем запустить Unreal Engine в браузере, даже вес страницы – не такая проблема (сериалы мы смотрим как-то и не жалуемся), но вычислительные мощности, необходимые, чтобы завелся серьезный проект на таком движке, очень некислые. Это будет не рендеринг видео на ночь, это будут задачи в реальном времени. Нужна хорошая видеокарта. Будет ли она у каждого нащего клиента? Вероятнее всего нет. Минимальные системные требования для сайта – такое себе решение. Очень редко мы можем их ввести без потери клиентов, это должен быть какой-то узкоспециализированный бизнес, который рассчитывает, что у клиентов будет нужное железо, или даже сам им его организует. Поэтому при изучении теоретически возможных инструментов и подходов в будущем – обращайте внимание и на то, насколько они вписываются в реальность здесь и сейчас.


### №18 (про чистый WebGL)

:heavy_plus_sign: - Частая задача при работе с WebGL - сделать какие-нибудь эффекты для фотографий на сайте. Волны разного рода, лупу под мышкой, какую-нибудь пикселизацию и.т.д. Там основа всего - это одна плоскость и шейдеры. В таких задачах функционал Three.js будет избыточным. Может быть 1% от него будет использоваться. В таких ситуациях может быть хорошой идеей отказаться от этого инструмента и перейти на чистый WebGL. Ну или на какую-то более легковесную библиотеку. Это положительно скажется на скорости загрузки страниц. В этом курсе мы используем Three.js в этой задаче только потому, что это промежуточный шаг, эти шейдеры потом будут использоваться для постобработки в рамках Three.js.


### №19 (про дискотеку у дизайнера)

:heavy_plus_sign: - Глядя на эту анимацию возникает впечатление, что она очень ядреная, слишком маленькая длительность для таких изменений цвета. В подводном мире все должно быть плавным и размеренным, а тут прямо дискотека. Если бы у нас был реальный проект, то это было бы поводом сходить к дизайнеру и спросить, а это ли он вообще имел в виду. Может быть и нет, просто не выспался и не заметил. Нужно помнить, что мы - последнее звено в процессе разработки, и именно нам нужно проверять ошибки дизайнера, не стесняясь задавать ему глупые вопросы. Даже если часть наших сомнений не подтвердятся - другая часть поможет исправить странности во внешнем виде сайта еще до того, как их увидят пользователи.

