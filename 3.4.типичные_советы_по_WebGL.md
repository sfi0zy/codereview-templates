# Типичные советы по WebGL


Здесь собираются типичные советы по WebGL.


## Ситуативные советы


### Про одну камеру и одну сцену

:point_up: - Имейте в виду, что в конечном счете все это будет одной 3D-сценой с одной камерой. При разработке может быть удобно иметь несколько камер, но потом все равно нужно будет все объединить. В контексте курса будет проще это сделать сейчас, пока кода мало.


### Про SVG extrude

:point_up: - Очевидно, что некоторые объекты поломались. Обратите внимание на направление замкнутых контуров в SVG, именно по нему определяется внутренняя часть контура для заливки цветом, или, как в нашем случае, для определения, где должны быть плоские грани объекта. Изменить направление контуров в SVG можно в любом векторном графическом редакторе. Также у метода toShapes у ShapePath в Three.js есть параметр, которым можно изменить прямое и обратное направления кривых (по крайней мере их интерпретацию в рамках текущей задачи).


## Закрепленные советы


### :lock: 5.01 (про советы при работе с Three.js)

:heavy_plus_sign: - Первоисточник информации в мире WebGL - [Khronos Group](https://www.khronos.org/). Если возникают какие-то вопросы по синтаксису, по тому, как что должно работать - их спецификации дадут ответы на все вопросы. И, раз уж мы занимаемся шейдерами, то стоит сразу положить в закладки спецификацию [OpenGL ES Shading Language](https://www.khronos.org/files/opengles_shading_language.pdf).

:heavy_plus_sign: - Полезно также положить себе в закладки какую-нибудь статью с типичными советами для работы с Three.js, [например эту](https://discoverthreejs.com/tips-and-tricks/), и иногда к ней возвращаться, осмысливая то, что там предлагается делать или не делать, особенно в вопросах производительности. Важно понимать, что чудес не бывает, но подобные стандартные советы все же могут помочь в некоторых ситуациях.

:heavy_plus_sign: - И еще замечание про зависимости: фиксирование версии Three.js в package.json - это скорее хорошая идея, чем плохая. Разработчики этого инструмента часто ломают обратную совместимость. Иногда они предупреждают в консоли о том, что изменилось, а иногда - просто появляются какие-то фантомные баги, связанные с рендерингом изображения. Их исправление - очень неприятное занятие, которое может усугубляться, если у разных членов команды в какие-то моменты времени были разные версии Three.js и какие-то куски проекта хорошо работают с одними версиями, какие-то - с другими, и никто уже точно не знает, какие с какими работали. Это, наверное, самая неприятная ситуация, которая может приключиться. Так что может иметь смысл фиксировать версию Three.js и потом при желании обновлять одновременно для всей команды, с последующим тестированием всего функционала.


### :lock: 5.02 (про шаблонные строки и чистый WebGL, про интуицию и эксперименты)

:heavy_plus_sign: - Написание шейдеров в шаблонных строках - решение не самое удобное. В первую очередь из-за потери подсветки синтаксиса и смешения всего в одну кучу. Альтернативно можно хранить код шейдеров в HTML, используя тег script, вроде `<script id='my-vertex-shader' type='x-shader/x-vertex'>`. Это может быть неплохим вариантом для небольших демок или еще чего-то, что должно работать без системы сборки. Часто можно встретить такой подход в примерах на CodePen. Там будет хоть какая-то подсветка синтаксиса. Но самый универсальный подход - хранить код шейдеров в отдельных файлах и подставлять их содержимое в JS-скрипты при сборке с помощью плагинов для webpack или других сборщиков - там много вариантов на любой вкус и цвет.

:heavy_plus_sign: - Частая задача при работе с WebGL - сделать какие-нибудь эффекты для фотографий на сайте. Волны разного рода, лупу под мышкой, какую-нибудь пикселизацию и.т.д. Там основа всего - это одна плоскость и шейдеры. В таких задачах функционал Three.js будет избыточным. Может быть 1% от него будет использоваться. В таких ситуациях может быть хорошой идеей отказаться от этого инструмента и перейти на чистый WebGL. Ну или на какую-то более легковесную библиотеку. Это положительно скажется на скорости загрузки страниц. В этом курсе мы используем Three.js в этой задаче только потому, что это промежуточный шаг, эти шейдеры потом будут использоваться для постобработки в рамках этого самого Three.js.

:heavy_plus_sign: - Разработка креативных сайтов с WebGL - это область, которая отличается от "обычного" фронтенда. Здесь мы очень часто будем попадать в ситуацию, когда готовых решений нет. Просто нет. Особенно если речь идет про визуальные эффекты. При работе в своеобразном информационном вакууме начинают проявляться понимание основ компьютерной графики и математическая интуиция. Именно не знание определений, каких-то умных слов, а понимание, что на что влияет. Поэтому здесь я, не в первый и не в последний раз, подтолкну вас к тому, чтобы интересоваться всем подряд и больше экспериментировать. Пробуйте делать разные штуки и смотрите, что из этого получается. Меняйте коэффициенты и знаки в формулах, совмещайте несовместимые вещи, даже если вы не знаете, что из этого выйдет, и где конкретно пригодится тот или иной эффект. Даже не так: если вы не знаете, что выйдет - это обязательно нужно попробовать и посмотреть. Также смотрите на чужие эксперименты, например вот [одна цепочка примеров на чистой WebGL](https://codepen.io/collection/NqYjJd) и [еще одна в рамках Three.js](https://codepen.io/collection/pgLwJp) *(иногда наблюдаются сбои в загрузке ресурсов с некоторых хостингов, сязанных с cloudflare, так что если вдруг демонстрации не работают - попробуйте включить vpn)*. На CodePen люди много всего интересного публикуют. Не ограничивайте себя учебником. В этом курсе вам встретится лишь одна задача про лупу, которая заставит вас думать над решением своей головой, но в работе таких будет много. Чем раньше вы начнете развивать в себе интуитивное понимание вещей, тем проще потом будет в работе.


### :lock: 5.03 (про RGB, HSL, HSB и стандарты)

:heavy_plus_sign: - Для общего развития полезно познакомиться также с разными цветовыми моделями, узнать разницу между RGB, HSL и HSB, и добавить в свой инструментарий функции конвертации цвета из одной в другую. В генеративной графике с яркими чистыми цветами часто гораздо удобнее все делать в HS\*, и только в конце конвертировать цвета в RGB для вывода на экран.

:heavy_plus_sign: - И еще напомню, что в GLSL есть набор стандартных математических функций. Полезно загуглить (посмотреть в спецификации) их список и познакомиться со всеми, если вы еще этого не сделали. Также в [этой статье](https://habr.com/ru/post/420847/) в начале есть спойлер с хорошими шпаргалками. Ну это так, на будущее, чтобы не изобретать велосипеды.

:heavy_plus_sign: - Изобретение велосипедов - занятие, полезное для обучения, но в работе использование стандартных, встроенных в язык, инструментов будет предпочтительнее, т.к. все ваши коллеги привыкли к стандартным обозначениям. Плюс в видеокартах некоторые стандартные функции выполняются быстрее, т.к. там все заоптимизировано с самых низов выполнять именно операции, скрытые за фасадом этих самых стандартных функций (набор которых в контексте GLSL совершенно не случайный).

:heavy_plus_sign: - В работе вы можете столкнуться с тем, что ваш вроде бы работающий код иногда работает, а иногда - нет. При этом никаких ошибок. Это называется undefined behavior - ситуация, когда код может быть скомпилирован по-разному и поведение программы будет зависеть от конкретного компилятора, от того, что происходит в памяти в конкретный момент выполнения программы, от фазы луны, или еще чего-то такого. В современном JS мы с этим не особо сталкиваемся, а вот в GLSL, C, C++, и.т.д. (фактически во всем семействе С) - это неопределенное поведение поджидает на каждом шагу. С подходом "чик-чик и в продакшен" мы можем легко получить программу, которая работает не всегда, не у всех пользователей. Этого нужно избегать. Обращайте внимание на то, какие параметры вы передаете в стандартные функции, и, если вы не уверены, как работает какая-то штука, и что в нее нужно передавать - стоит открыть спецификацию и проверить свои предположения. Там нигде нет "защиты от дурака", поэтому корректность данных нужно всегда проверять самостоятельно.


### :lock: 5.04 (про хардкод)

:heavy_plus_sign: - Строго говоря, эта анимация с пузырьками полностью генеративная, здесь никакие параметры извне не нужны и все можно захардкодить прямо в шейдере. В реальном мире не надуманных заданий такой грубый подход часто позволяет в разы сократить количество кода без каких-либо последствий. Часто можно оставить только время и размеры канваса в качестве параметров, и этого будет достаточно.


### :lock: 5.05 (про вершинные шейдеры)

:heavy_plus_sign: - Ваш учебник в основном раскрывает тему работы с фрагментными шейдерами, но для общего развития будет полезно поэкспериментировать и с вершинными тоже. С их помощью можно легко делать [занятные генеративные штуки](https://codepen.io/sfi0zy/pen/ZEGovzm) и разного рода эффекты с трансформациями, которые довольно востребованы в разработке рекламно-конкурсных сайтов.


### :lock: 5.06 (про дискотеку у дизайнера)

:heavy_plus_sign: - Глядя на эту анимацию возникает впечатление, что она очень ядреная. Слишком маленькая длительность для таких изменений цвета. В подводном мире все должно быть плавным и размеренным, а тут прямо дискотека. Если бы у нас был реальный проект, то это было бы поводом сходить к дизайнеру и спросить, а это ли он вообще имел в виду. Может быть и нет, просто не выспался и не заметил. Нужно помнить, что обычно мы - последнее звено в процессе разработки, и именно нам нужно проверять ошибки дизайнера, не стесняясь задавать ему глупые вопросы. Дальше - только конечные пользователи. Даже если часть наших сомнений не подтвердятся - другая часть поможет исправить странности во внешнем виде сайта еще до того, как их увидят все.


### :lock: 5.07 (про WebGL Fluid Simulation и фракталы)

:heavy_plus_sign: - По теме шейдеров будет полезно дополнительно познакомиться с библиотекой [WebGL Fluid Simulation](https://paveldogreat.github.io/WebGL-Fluid-Simulation/), если вы еще не знакомы. В учебном проекте все нужно делать без использования сторонних библиотек, но это популярный инструмент, про который стоит знать.

:heavy_plus_sign: - Для общего развития будет полезно написать свою рисовалку [множества Мандельброта](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%9C%D0%B0%D0%BD%D0%B4%D0%B5%D0%BB%D1%8C%D0%B1%D1%80%D0%BE%D1%82%D0%B0) на WebGL. Эта технология просто создана для рисования подобных фракталов. На примере такой программы можно будет попрактиковаться в разных вещах - там и геометрические расчеты для зума и перемещения камеры, и генеративные цветовые схемы, можно анимации какие-нибудь прикрутить. В общем это может быть неплохой площадкой для экспериментов. А эксперименты дают понимание, как все работает.


### :lock: 6.01 (про отладку света, тени и компьютерную графику)

:point_up: - При отладке света на сцене может быть хорошей идеей сделать источники света разноцветными. Например один ядрено-зеленым, другой ядрено-розовым и.т.д. Это позволит лучше видеть световой рисунок на сцене и будет проще подобрать параметры для источников света.

:point_up: - Также на время разработки можно подключить [OrbitControls](https://threejs.org/docs/#examples/en/controls/OrbitControls), чтобы крутить сцену и видеть ее с разных сторон. Это может быть полезно и при отладке света, и при расстановке объектов на сцене.

:heavy_plus_sign: - Полезно при изучении разных штук в рамках Three.js обращать внимание и на то, что скрыто внутри них. Это – библиотека, набор готовых решений каких-то задач из мира компьтерной графики, и хорошо знать, что там происходит внутри. Не только для общего развития кругозора, но и для понимания, что и почему может повлиять на производительность, куда смотреть, если на экране появляются какие-то артефакты и.т.д. Например понимание алгоритмов, как рассчитываются тени от точечных источников света, может дать ответы на вопросы о том, почему много источников света с тенями – это беда для телефонов и встроенных видеокарт, или почему границы теней вдруг пошли квадратиками и что с этим делать. Все это выходит за границы курса, но если вы хотите погрузиться в саму предметную область и решать задачи, выходящие за рамки примеров из документации – читайте больше статей и книг по компьютерной графике. Все, до чего руки доберутся. И, что важно - от разных авторов, с разными специализациями. Математики, физики, программисты - каждый будет давать вам что-то от себя, свой контекст задач, формируя разностороннее видение отрасли, хотя по сути все книги будут про одно и то же. Конкретные инструменты меняются, но общие принципы формирования того же 2D изображения из 3D сохраняются десятки лет. Видимое развитие компьютерной графики за последние 20 лет больше связано с тем, что появились доступные широкому кругу людей вычислительные мощности, которые могут в реальном времени что-то там расчитать, чем с серьезными изменениями в математических основах. Там все происходит очень неспешно.


### :lock: 6.02 (про библиотеку моделей и материалов)

:heavy_plus_sign: - В таких проектах часто идут по пути создания отдельной библиотеки моделей, текстур, материалов и.т.д. Она в начале инициализируется сама в себе, а потом все сцены из нее берут только то, что им нужно. Это помогает и не делать несколько раз одно и то же в разных сценах, и разделяет код проекта на логические части, его проще понимать, и за процессом загрузки следить удобнее (прелоадер тот же самый с процентами - намного проще сделать, чем если код создания всех моделей и материалов будет размазан по всему проекту). Здесь будет много заданий про загрузку моделей разными способами и может быть полезно подумать над разными способами организации всего этого кода.


### :lock: 6.03 (про instancedMesh)

:heavy_plus_sign: - Одна из задач, сопутствующих загрузке моделей - это их переиспользование. В учебном проекте почти все, что есть, используется в количестве одной штуки. Но в более замороченных проектах может быть нужно использовать какую-то модель много раз. Стоит запомнить, что для таких случаев есть [instancedMesh](https://threejs.org/docs/?q=mesh#api/en/objects/InstancedMesh). В учебнике на этом особого акцента не делается, но если будет нужно рендерить действительно много экземпляров одного и того же, то эта штука может очень сильно сэкономить ресурсы. Плюс это - распространенная абстракция, которая может вам встретиться и в других библиотеках.


### :lock: 6.04 (про BufferGeometry)

:heavy_plus_sign: - Генерирование геометрий, и, в частности, полностью своих геометрий - это относительно частая задача в генеративной графике. К сожалению в учебном проекте это просто негде применить. Дизайн такой. Ничего не поделаешь. Но для своего кругозора имеет смысл потом загуглить эту тему, начав с [BufferGeometry](https://threejs.org/docs/?q=geometry#api/en/core/BufferGeometry) в документации к Three.js и примеров оттуда. Там есть общая для многих инструментов в мире компьютерной графики идея, что мы можем перечислить список вершин (координаты), список полигонов-треугольников (какие вершины для каких использовать), список цветов (какую вершину как нужно покрасить, возможно это будет связано с текстурами), и список нормалей (перпендикуляры к поверхности, чтобы понимать, как свет рассчитывать). В результате получится свой хитрый объект. В рамках Three.js логика формирования этих списков уже реализована для плоскостей, кубиков, сфер, и что там еще есть. Мы не задумываемся, но она там есть. А если возникнет потребность, то можно вручную сделать любую геометрию, используя те же инструменты.


### :lock: 6.05 (про кеширование материалов)

:heavy_plus_sign: - В учебном проекте объекты мало пересекаются по материалам, поэтому тут этому можно не придать значения, но подчеркну момент, что в проектах более крупных имеет смысл следить за тем, чтобы не создавались дублирующие друг друга материалы. Это может заметно повлиять на производительность страницы в целом, особенно если там идут материалы с текстурами или используется сложное освещение. Если у нас создается 100500 объектов с одним по смыслу материалом, то было бы хорошо его создать только один раз. Или на месте, при создании объектов, или, если в архитектуре проекта предусмотрена отдельная фабрика материалов, то можно в ней предусмотреть какой-то механизм сохранения материалов для переиспользования. Внутри Three.js есть какой-то механизм кеширования, но работает он не очень предсказуемо, и его поведение меняется от версии к версии. Надежнее иметь свой.


### :lock: 6.06 (про расширение материалов)

:point_up: - По всей видимости формулировка задания путает, но то, что вы сделали - это не совсем то, что нужно. Ваши шейдеры дают вам только текстуру на поверхности объектов. Это работает. Но по идее нужно туда же интегрировать всю логику работы материалов, которая уже есть в Three.js (свет, тени, отражения и.т.д.). Смысл расширения материалов именно в том, чтобы совместить готовое с дополнительной функциональностью, а в вашем случае получается, что вы делаете материал, в котором есть ваша логика, но полностью отсутствует логика из стандартных материалов. У вас в целом все получается, так что задание будет формально принято, но с напутствием разобраться в этой теме.

:heavy_plus_sign: - Полезно познакомиться с альтернативным решением, не упомянутом в учебнике: у материалов есть [onBeforeCompile](https://threejs.org/docs/#api/en/materials/Material.onBeforeCompile), можно прямо перед компиляцией шейдеров для материалов их модифицировать, в частности интегрировать туда свои шейдерно-сгенерированные текстуры, [например вот так](https://codepen.io/sfi0zy/pen/XWerBEM).

:heavy_plus_sign: - Для расширения кругозора можно познакомиться с еще одним решением этой задачи: если нужно сгенерировать текстуру и при этом воспользоваться стандартными свойствами материалов из Three.js (тени, блики и.т.д.), и если текстуру сложно сообразить в рамках одного шейдера, то можно все нарисовать на отдельном канвасе, в том числе на 2D, и использовать его как текстуру, [например как в этой демонстрации](https://codepen.io/sfi0zy/pen/NQOdGd). А еще так можно выводить видео на поверхность модели. А в теории можно и результат, полученный после выполнений шейдеров, сохранять и переиспользовать в других шейдерах, или даже в тех же самых. Но к этому мы еще вернемся в будущем. Важно понять идею, что текстура - это понятие очень растяжимое, по сути это картинка, а картинки можно переиспользовать в самых разных комбинациях.


### :lock: 6.07 (про оптимизацию моделей)

:heavy_plus_sign: - В целях общего развития может быть полезно взять какой-нибудь 3D-редактор, например [Blender](https://www.blender.org/) (он бесплатный и кроссплатформенный), и посмотреть на то, как устроены сложные модели:

![](https://habrastorage.org/webt/kd/cr/_g/kdcr_gim0p3ttq3gfyc-2wetv1g.jpeg)

:heavy_plus_sign: - На примере самолета из курса можно посмотреть пример модели, которую в контексте фронтенда нужно бы отправить на доработку. Количество вершин здесь можно уменьшить на порядок, без какого-либо влияния на видимый результат. Например такая детализация окон нам в проекте точно не нужна - самолетик слишком маленький, чтобы что-то там разглядеть. По идее нам нужно стремиться к использованию low poly моделей и этот факт в требования нужно закладывать сразу, еще до создания моделей. И на этом моменте можно улучшить не только размеры модели (и скорость ее загрузки по сети), но и общую производительность, т.к. значительно снизятся требования для видеокарты. Мне встречались проекты, где только оптимизация моделей позволяла увеличить средний fps на сайте с 2-3 кадров до 30-40 на ноутбуке с обычной UHD Graphics.


### :lock: 6.08 (про разное управление камерой)

:heavy_plus_sign: - При сборке сцен иногда может быть удобно повключать разные варианты управления камерой. [OrbitControls](https://threejs.org/docs/?q=controls#examples/en/controls/OrbitControls) - это хороший вариант для простых сцен, но в более сложных, где есть объекты разного размера и их внутренности, может быть проще использовать [FlyControls](https://threejs.org/docs/?q=controls#examples/en/controls/FlyControls). Камера не будет фокусироваться на конкретном объекте, и ей можно будет летать везде. Это будет похоже на то, как камера работает в 3D-редакторах. Вообще в Three.js есть разные варианты управления камерой, можно со всеми познакомиться. Вдруг пригодится.


### :lock: 6.09 (про сборку)

:heavy_plus_sign: - В учебнике у вас предлагается собирать сцены прямо в браузере. Это иногда может быть уместно, если они интерактивные или если там что-то рандомизируется, так что практика лишней не будет. Но если смотреть со стороны, то в контексте сцен комнат такой выбор инструмента выглядит странно. В большинстве случаев при работе со статичными сценами их будет куда быстрее собирать в рамках 3D-редактора и загружать в уже собранном виде.


### :lock: 6.10 (про тени и FPS)

:point_up: - Обратите внимание на то, что у нас могут пойти артефакты по всем объектам, которые принимают тени. Без знаний из мира компьютерной графики такие проблемы сложно загуглить, поэтому оставлю тут алгоритм, куда бы я смотрел, если бы увидел что-то такое в своем проекте. Ну и намекну еще раз, что базовые знания бывают нужны не только на словах. У нас есть три стандартных шага, которые можно предпринять, чтобы избавиться от артефактов: первый - увеличить размер карт теней (shadow map) для источников света и по возможности уменьшить объем пространства (frustum) в котором источники света работают. Это уберет пикселизацию теней. До бесконечности увеличивать нельзя, в браузерах есть ограничения. Плюс расчет карт теней сам по себе - операция затратная, так что тут нужно знать меру. Второй шаг - смещение теней (bias). Это такой хитрый костыль в алгоритме расчета теней, который может убрать муар. Третий - у рендерера можно выбрать тип карты теней. Иногда выбор алгоритма, по которому рассчитываются тени, может влиять на результат. Поскольку в вашем проекте артефакты теней определенно присутствуют - стоит попробовать их починить.

:heavy_plus_sign: - В проекте постепенно накапливаются вопросы по части производительности. Будет полезно узнать, что стандартные инструменты разработчика, например FPS-meter в Chrome, могут сильно привирать при работе с канвасом. По их показаниям может казаться, что все хорошо, но глазами видно, что это не так. Или наоборот - все работает хорошо, а инструмент говорит, что все плохо. Здесь все так же, как и с PageSpeed Insights, если вы понимаете, о чем я. В основном причины этого кроются в том, что у нас из браузера не так много (фактически вообще нет) возможностей получать полную и достоверную информацию о происходящем на видеокарте. В качестве альтернативы FPS-meter можно сделать какое-нибудь свое решение или взять [stats.js](https://github.com/mrdoob/stats.js/). Кажется, что это самый популярный инструмент для отображения FPS среди разработчиков, связанных с Three.js.

:point_up: - У вас в критерии Б1 говорится, что анимация должна быть сделана без сторонних библиотек, но здесь речь именно про отладку, это можно потом убрать перед защитой.


### :lock: 6.11 (про анимации)

:heavy_plus_sign: - Раз уж у нас все возвращается к собственно анимациям, стоит сказать, что в Three.js действительно есть [своя инфраструктура для анимаций](https://threejs.org/docs/?q=animation#manual/en/introduction/Animation-system). В учебнике было пару слов про нее. У нее долгое прошлое. Что-то она умеет, что-то не умеет, в чем-то похожа на то, как это устроено в игровых движках. Но практика показывает, что люди из мира фронтенда ей редко пользуются. Обычно в проектах уже есть тот же GSAP, и нет нужды его дублировать. Главная фишка этой встроенной системы анимаций - это возможность проигрывать экспортированные анимации из 3D-редакторов. Это главная причина к ней обратиться. Но я бы здесь предостерег от поспешных выводов о ней. Там много подводных камней. Например не во всех форматах моделей можно сохранить анимации, где-то нельзя иметь большое их количество, где-то их нужно организовать особым образом и.т.д. Если вдруг возникнет возможность построить процесс разработки с перспективой что-то экспортировать и проигрывать в рамках Three.js - стоит сразу погуглить, насколько это будет реалистично, и какие на месте могут возникнуть требования к моделям, чтобы 3D-художники сразу понимали, куда все идет. Если в этом процессе что-то пойдет не так, то это может стать блокирующей проблемой в проекте.


### :lock: 7.01 (про скелеты)

:heavy_plus_sign: - Тут вы можете обратить внимание, что идея сделать обертки вокруг элемента для разных трансформаций, чтобы разделить сложное движение на ряд простых, не новая. Мы такое делаем и в рамках CSS, и в SVG. Часто проще рассчитывать расположение объектов относительно других объектов, а не относительно всего мира. Но в рамках компьютерной графики в целом есть еще такая популярная абстракция для вычисления расположения вершин объектов, как скелеты. Оно может по-разному называться, но оставлю ссылку на [пример в рамках Three.js](https://threejs.org/docs/#api/en/objects/SkinnedMesh). Сочетание таких скелетов с вложением объектов друг в друга позволяет делать очень много всякого разного. В учебных заданиях тема скелетных анимаций не затрагивается, но в работе может пригодиться. Имеет смысл познакомиться.


### :lock: 7.02 (про термины и размерности)

:heavy_plus_sign: - В учебнике на этом внимание не акцентируется, но я бы добавил одну мысль: если моделируется какое-то физическое явление, какой-то известный науке объект, то может иметь смысл использовать общепринятые термины для обозначения разных величин. У самолета там будет крен, тангаж, рыскание и.т.д. Особенно польза будет заметна если они потом используются в каких-то формулах, где нужно не только понимать, что есть что, но и важны знаки. Или если какие-то из величин логически связывают разные объекты. Например у более продвинутого самолета могли бы быть визуально заметные рули, которые тоже бы поворачивались. Тут задание маленькое, поэтому пользу от такого подхода оценить сложно, но в более замороченных задачах стандартное именование всего может упростить работу.

:heavy_plus_sign: - И сопутствующая мысль, которая тоже не очень акцентируется в учебнике, но часто встречается в мире компьютерной графики: при работе с физическими явлениями очень (вот прям очень очень) удобно считать условную единицу размерности пространства (в WebGL в нашем случае) равной одному физическому метру. Это заметно упрощает понимание происходящего.


### :lock: 7.03 (про тесты и порталы)

:heavy_plus_sign: - Если у нас есть множественные переходы между сценами в 3D, как в этом проекте, то нужно держать у себя в голове, что переходы бывают между всеми сценами. 5 сцен = 20 возможных переходов. Понятно, что они там типовые, какие-то мы можем заблокировать, но тем не менее. Важно дизайнера пинать, чтобы он описывал логику всех возможных переходов, а не только основных. Ну и реализовывать ее, соответственно. Иногда для этого могут понадобиться какие-то трюки с пространством. На примере этого проекта - мы можем перемещать сцену с замочной скважиной за спиной у камеры, чтобы она всегда была доступна для пролета камеры назад из любой комнаты. В более сложном варианте возможно создание логики порталов, когда одна сцена существует в 3D-мире больше одного раза, и за счет этого мы можем создавать эффекты в духе "пройти вперед в дверь, которая находится за спиной". Или можно взять дополнительную камеру, отрендерить сцену в нее, сохранить в текстуру, а потом использовать эту текстуру для какого-то объекта внутри этой самой сцены. В общем в вопросах перемещения камеры мы можем не только ее двигать, но и менять строение пространства вокруг.


### :lock: 7.04 (про lightMap и envMap)

:heavy_plus_sign: - Летающие источники света с тенями - это красиво, но они требует вычислительных мощностей для работы. Чем больше источников - тем больше это все будет требовать. Обычно в проектах со сложным освещением люди стараются уменьшить количество источников света, которые на самом деле должны двигаться, делают так, чтобы они по возможности все же стояли на месте. Это открывает путь к использованию такой штуки, как [lightMap](https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.lightMap). Грубо говоря мы собираем сцену в 3D-редакторе, нажимаем кнопку, и получаем текстуру, в которой сохранена информация об освещении. Потом в реальном времени мы уже никакой свет не рассчитываем, а используем цвета из этой текстуры. Не знаю, почему в учебнике на этом не делается акцента, но такие карты света и теней крайне положительно влияют на производительность. И сопутствующая вещь - [envMap](https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.envMap). То же самое, но в эту текстуру сохраняется информация об отражениях окружающего мира на 3D-объектах. В рекламной индустрии ее часто используют для создания реалистичных отражений на товарах, вплоть до того, что катаются по улицам с 360-камерой, а потом из полученных изображений генерируют отражения для каких-нибудь моделей машин, которые никогда на этих улицах не были. Но в нашем контексте главным поводом для их использования опять же будет экономия ресурсов. Физически правильные отражения - тоже задачка требовательная.


### :lock: 7.05 (про траектории камеры)

:heavy_plus_sign: - В больших проектах может быть хорошей идеей предусмотреть какой-нибудь флаг, который временно включает для отладки вторую камеру и позволяет посмотреть на первую с помощью [CameraHelper](https://threejs.org/docs/#api/en/helpers/CameraHelper). А если для нее используется какой-то подвес, то его тоже хорошо бы сделать видимым. Иногда такой "режим разработчика" помогает спроектировать какое-то сложное движение или разобраться с багами. Неконтролируемый вид от первого лица не всегда хорош для отладки.


### :lock: 7.06 (про Open Gate и киноделов)

:heavy_plus_sign: - По идее про кадрирование лучше думать до того, как создавать сцены, а не пытаться впихнуть все в кадр уже постфактум. И тут я могу подкинуть такую мысль для расширения кругозора, что в мире киноделов сейчас модно обсуждать запись видео в режиме open gate, с разным кадрированием результата под разные социальные сети. У них можно подчерпнуть много идей по поводу того, как строить сцены, чтобы они хорошо кадрировались где-то потом.

:heavy_plus_sign: - И, раз уж речь зашла про эту индустрию, то скажу, что съемки видео, vfx, наш фронтенд с 3D-сценам - это все крайности одной и той же сущности. Мы во многих вопросах оперируем одними и теми же абстракциями, просто в нашем случае акцент больше смещен в сторону программирования. Поэтому если вы решите строить свой путь в сторону каких-то рекламно-конкурсных проектов, изучение чего-то такого может стать одним из направлений дальнейшего развития, после того, как освоитесь с текущими инструментами. Программисты могут вам рассказать, что технически можно сделать, а режиссеры и операторы - зачем это делать. Они могут и про свет рассказать (какие источники какие эффекты дают), и про цвет (мы даже их любимые пленочные LUTы можем использовать), и про движения камеры (по сути все, что было про риги в учебнике - это было про имитации слайдеров, кранов и стабилизаторов для настоящих камер), и про естественность картинки, motion blur и колебания в яркости кадров, и про разделение планов, про работу с глубиной резкости, туманом и.т.д. Некоторые вещи будут требовать слишком больших вычислительных мощностей, но очень многие идеи из кино мы все же можем адаптировать к нашим задачам.


### :lock: 7.07 (про оптимизацию для телефонов)

:heavy_plus_sign: - Есть некоторая ирония в том, что после отключения теней, как предлагается в задании, сайт начинает работать заметно шустрее на телефоне, а не на ноутбуке.

:heavy_plus_sign: - Не стоит надеяться на то, что получится оптимизировать проект, который явно тормозит, при этом сохранив изначальную концепцию и красивую картинку. Если все плохо - придется жертвовать сложными для вычисления вещами. А вся красота обычно именно в них. Без теней ваш проект работает лучше, но выглядит... Не так приколько, как с ними. И тени - это только вершина айсберга. В мире компьютерной графики много вещей требуют вычислительных мощностей для работы. Отчасти по этой причине мне кажется хорошей идеей подобные проекты делать всегда в обратную сторону - начинать с прототипа трехмерной части, смотреть, насколько она работоспособной получается, и уже потом, если все ок, верстать все остальное. Ну а если мы о чем-то не подумали заранее и все не ок, то это обнаруживается сразу, а не перед дедлайном. Есть возможность поменять концепцию в дизайне, заменить 3D на видео, или вообще от него отказаться в пользу каких-то 2D-эффектов в том же стиле. Проекты бывают разные, требования тоже, и не всегда можно вот так просто выключить освещение и решить все проблемы.


### :lock: 7.09 (про постпроцессинг и баги буфера глубины)

[ СКРИНШОТ ПРОЕКТА СТУДЕНТА (АНАЛОГИЧНАЯ КАРТИНКА ДЛЯ ПРИМЕРА) ]

![](https://habrastorage.org/webt/3n/dj/lg/3ndjlgwnetjbrplvrzjoy1fbk8m.jpeg)

:point_up: - В данном случае проблема проявилась в последнем Хроме под линуксом с графикой UHD Graphics 605, хотя могла проявиться и где-нибудь еще, например в Safari.

:point_up: - WebGL опускает нас к более низкому уровню работы с железом, мы уже не находимся в привычной песочнице javascript, в которой от железа не зависит почти ничего. И у разных браузеров на разном железе могут быть разные ограничения, например на максимальный размер текстуры или карты теней. По-хорошему проекты с WebGL нужно тестировать не только в разных браузерах, но и на разном железе (хотя, конечно, бюджет не всегда это позволяет). Плюс библиотека Three.js, если уж мы ее используем, накладывает сверху свою логику, в которой тоже есть не самые очевидные wtf-моменты, например добавление постобработки меняет то, как основной рендерер работает с буфером глубины и может произойти то, что видно на скриншоте. Причем такие проблемы могут проявляться как в виде "не работает в разных браузерах на одном компьютере", так и в виде "не работает в одинаковых браузерах на разных компьютерах". В данном случае вопрос можно решить, если руками включить логарифмический буфер глубины у рендерера. Это даст минус к производительности, но плюс к надежности. И это хороший пример ситуации, когда знания из области компьютерной графики нужны не просто на словах. Пошли артефакты по экрану, проектом невозможно пользоваться, и при этом проблему очень сложно загуглить (я пробовал). Инструменты разработчика не дают абсолютно никакой полезной информации. Догадаться о том, что что-то не так с буфером глубины можно только если знать, что это такое, и как он работает.


### :lock: 8.01 (про розовые очки)

:heavy_plus_sign: - К последнему заданию на курсе повторю мысли о суровой реальности: мы можем запустить Unreal Engine в браузере, даже вес страницы – не такая проблема (сериалы мы смотрим как-то и не жалуемся), но вычислительные мощности, необходимые, чтобы завелся серьезный проект на таком движке, очень некислые. Это будет не рендеринг видео на ночь, это будут задачи в реальном времени. Нужна хорошая видеокарта. Будет ли она у каждого нашего клиента? Вероятнее всего нет. Минимальные системные требования для сайта – такое себе решение. Очень редко мы можем их ввести без потери клиентов, это должен быть какой-то узкоспециализированный бизнес, который рассчитывает, что у клиентов будет нужное железо, или даже сам им его организует. Это же можно сказать не только про вычислительные мощности, но и про поддержку разных штук браузерами. Например WebGPU упоминают в вакансиях уже несколько лет, рассказывают красивые сказки про замечательное API (это как бы правда - после WebGL смотреть на WebGPU приятно), но по факту [все очень печально](https://caniuse.com/webgpu). Технология WebGL2 хоть и [выглядит получше](https://caniuse.com/?search=webgl2), но еще пару лет назад вызывала много вопросов по части надежности. Только получившая "зеленую" поддержку технология была откровенно сырой, с кучей сложноисправляемых и абсолютно не гуглящихся багов. Стоит серьезно думать, прежде чем притягивать такого рода технологии в проект - исправить решение на стадии глубокой разработки будет очень непросто. При изучении теоретически возможных инструментов и подходов в будущем – обращайте внимание на то, насколько они вписываются в реальность здесь и сейчас.

