# Типичные советы по WebGL


Здесь собираются типичные советы по WebGL.


## Ситуативные советы


### Про одну камеру и одну сцену

:point_up: - Имейте в виду, что в конечном счете все это будет одной 3D-сценой с одной камерой. При разработке может быть удобно иметь несколько камер, но потом все равно нужно будет все объединить. В контексте курса будет проще это сделать сейчас, пока кода мало.


### Про SVG extrude

:point_up: - Очевидно, что некоторые объекты поломались. Обратите внимание на направление замкнутых контуров в SVG, именно по нему определяется внутренняя часть контура для заливки цветом, или, как в нашем случае, для определения, где должны быть плоские грани объекта. Изменить направление контуров в SVG можно в любом векторном графическом редакторе. Также у метода toShapes у ShapePath в Three.js есть параметр, которым можно изменить прямое и обратное направления кривых (по крайней мере их интерпретацию в рамках текущей задачи).


## Закрепленные советы


### :lock: 5.01 (про советы при работе с Three.js)

:heavy_plus_sign: - Первоисточник информации в мире WebGL - [Khronos Group](https://www.khronos.org/). Если возникают какие-то вопросы по синтаксису, по тому, как что должно работать - их спецификации дадут ответы на все вопросы. И, раз уж мы занимаемся шейдерами, то стоит сразу положить в закладки спецификацию [OpenGL ES Shading Language](https://www.khronos.org/files/opengles_shading_language.pdf).

:heavy_plus_sign: - Полезно также положить себе в закладки какую-нибудь статью с типичными советами для работы с Three.js, [например эту](https://discoverthreejs.com/tips-and-tricks/), и иногда к ней возвращаться, осмысливая то, что там предлагается делать или не делать, особенно в вопросах производительности. Важно понимать, что чудес не бывает, но подобные стандартные советы все же могут помочь в некоторых ситуациях.

:heavy_plus_sign: - И еще замечание про зависимости: фиксирование версии Three.js в package.json - это скорее хорошая идея, чем плохая. Разработчики этого инструмента часто ломают обратную совместимость. Иногда они предупреждают в консоли о том, что изменилось, а иногда - просто появляются какие-то фантомные баги, связанные с рендерингом изображения. Их исправление - очень неприятное занятие, которое может усугубляться, если у разных членов команды в какие-то моменты времени были разные версии Three.js и какие-то куски проекта хорошо работают с одними версиями, какие-то - с другими, и никто уже точно не знает, какие с какими работали. Это, наверное, самая неприятная ситуация, которая может приключиться. Так что может иметь смысл фиксировать версию Three.js и потом при желании обновлять одновременно для всей команды, с последующим тестированием всего функционала.


### :lock: 5.02 (про шаблонные строки и чистый WebGL, про интуицию и эксперименты)

:heavy_plus_sign: - Написание шейдеров в шаблонных строках - решение не самое удобное. В первую очередь из-за потери подсветки синтаксиса и смешения всего в одну кучу. Альтернативно можно хранить код шейдеров в HTML, используя тег script, вроде `<script id='my-vertex-shader' type='x-shader/x-vertex'>`. Это может быть неплохим вариантом для небольших демок или еще чего-то, что должно работать без системы сборки. Часто можно встретить такой подход в примерах на CodePen. Там будет хоть какая-то подсветка синтаксиса. Но самый универсальный подход - хранить код шейдеров в отдельных файлах и подставлять их содержимое в JS-скрипты при сборке с помощью плагинов для webpack или других сборщиков - там много вариантов на любой вкус и цвет.

:heavy_plus_sign: - Частая задача при работе с WebGL - сделать какие-нибудь эффекты для фотографий на сайте. Волны разного рода, лупу под мышкой, какую-нибудь пикселизацию и.т.д. Там основа всего - это одна плоскость и шейдеры. В таких задачах функционал Three.js будет избыточным. Может быть 1% от него будет использоваться. В таких ситуациях может быть хорошой идеей отказаться от этого инструмента и перейти на чистый WebGL. Ну или на какую-то более легковесную библиотеку. Это положительно скажется на скорости загрузки страниц. В этом курсе мы используем Three.js в этой задаче только потому, что это промежуточный шаг, эти шейдеры потом будут использоваться для постобработки в рамках этого самого Three.js.

:heavy_plus_sign: - Разработка креативных сайтов с WebGL - это область, которая отличается от "обычного" фронтенда. Здесь мы очень часто будем попадать в ситуацию, когда готовых решений нет. Просто нет. Особенно если речь идет про визуальные эффекты. При работе в своеобразном информационном вакууме начинают проявляться понимание основ компьютерной графики и математическая интуиция. Именно не знание определений, каких-то умных слов, а понимание, что на что влияет. Поэтому здесь я, не в первый и не в последний раз, подтолкну вас к тому, чтобы интересоваться всем подряд и больше экспериментировать. Пробуйте делать разные штуки и смотрите, что из этого получается. Меняйте коэффициенты и знаки в формулах, совмещайте несовместимые вещи, даже если вы не знаете, что из этого выйдет, и где конкретно пригодится тот или иной эффект. Даже не так: если вы не знаете, что выйдет - это обязательно нужно попробовать и посмотреть. Также смотрите на чужие эксперименты, например вот [одна цепочка](https://habr.com/ru/post/420847/) и [ее продолжение](https://habr.com/ru/post/421821/) *(в последнее время наблюдаются сбои в загрузке ресурсов с некоторых хостингов, сязанных с cloudflare, так что если демонстрации в статьях не работают - включите vpn)*. На CodePen люди много всего интересного публикуют. Не ограничивайте себя учебником. В этом курсе вам встретится лишь одна задача про лупу, которая заставит вас думать над решением своей головой, но в работе таких будет много. Чем раньше вы начнете развивать в себе интуитивное понимание вещей, тем проще потом будет в работе.


### :lock: 5.03 (про RGB, HSL, HSB и стандарты)

:heavy_plus_sign: - Для общего развития полезно познакомиться также с разными цветовыми моделями, узнать разницу между RGB, HSL и HSB, и добавить в свой инструментарий функции конвертации цвета из одной в другую. В генеративной графике с яркими чистыми цветами часто гораздо удобнее все делать в HS\*, и только в конце конвертировать цвета в RGB для вывода на экран.

:heavy_plus_sign: - И еще напомню, что в GLSL есть набор стандартных математических функций. Полезно загуглить (посмотреть в спецификации) их список и познакомиться со всеми, если вы еще этого не сделали. Также в [этой статье](https://habr.com/ru/post/420847/) в начале есть спойлер с хорошими шпаргалками. Ну это так, на будущее, чтобы не изобретить велосипеды.

:heavy_plus_sign: - Изобретение велосипедов - занятие, полезное для обучения, но в работе использование стандартных, встроенных в язык, инструментов будет предпочтительнее, т.к. все ваши коллеги привыкли к стандартным обозначениям. Плюс в видеокартах некоторые стандартные функции выполняются быстрее, т.к. там все заоптимизировано с самых низов выполнять именно операции, скрытые за фасадом этих самых стандартных функций (набор которых в контексте GLSL совершенно не случайный).

:heavy_plus_sign: - В работе вы можете столкнуться с тем, что ваш вроде бы работающий код иногда работает, а иногда - нет. При этом никаких ошибок. Это называется undefined behavior - ситуация, когда код может быть скомпилирован по-разному и поведение программы будет зависеть от конкретного компилятора, от того, что происходит в памяти в конкретный момент выполнения программы, от фазы луны, или еще чего-то такого. В современном JS мы с этим не особо сталкиваемся, а вот в GLSL, C, C++, и.т.д. (фактически во всем семействе С) - это неопределенное поведение поджидает на каждом шагу. С подходом "чик-чик и в продакшен" мы можем легко получить программу, которая работает не всегда, не у всех пользователей. Этого нужно избегать. Обращайте внимание на то, какие параметры вы передаете в стандартные функции, и, если вы не уверены, как работает какая-то штука, и что в нее нужно передавать - стоит открыть спецификацию и проверить свои предположения. Там нигде нет "защиты от дурака", поэтому корректность данных нужно всегда проверять самостоятельно.


### :lock: 5.04 (про хардкод)

:heavy_plus_sign: - Строго говоря эта анимация полностью генеративная, здесь никакие параметры извне не нужны и все можно захардкодить прямо в шейдере. В реальном мире не надуманных заданий такой грубый подход часто позволяет в разы сократить количество кода без каких-либо последствий. Часто можно оставить только время и размеры канваса в качестве параметров, и этого будет достаточно.


### :lock: 5.05 (про вершинные шейдеры)

:heavy_plus_sign: - Ваш учебник в основном раскрывает тему работы с фрагментными шейдерами, но для общего развития будет полезно поэкспериментировать и с вершинными тоже. С их помощью можно легко делать [занятные генеративные штуки](https://codepen.io/sfi0zy/pen/ZEGovzm) и разного рода эффекты с трансформациями, которые довольно востребованы в разработке рекламно-конкурсных сайтов.


### :lock: 5.06 (про дискотеку у дизайнера)

:heavy_plus_sign: - Глядя на эту анимацию возникает впечатление, что она очень ядреная. Слишком маленькая длительность для таких изменений цвета. В подводном мире все должно быть плавным и размеренным, а тут прямо дискотека. Если бы у нас был реальный проект, то это было бы поводом сходить к дизайнеру и спросить, а это ли он вообще имел в виду. Может быть и нет, просто не выспался и не заметил. Нужно помнить, что обычно мы - последнее звено в процессе разработки, и именно нам нужно проверять ошибки дизайнера, не стесняясь задавать ему глупые вопросы. Дальше - только конечные пользователи. Даже если часть наших сомнений не подтвердятся - другая часть поможет исправить странности во внешнем виде сайта еще до того, как их увидят все.


### :lock: 5.07 (про WebGL Fluid Simulation и фракталы)

:heavy_plus_sign: - По теме шейдеров будет полезно дополнительно познакомиться с библиотекой [WebGL Fluid Simulation](https://paveldogreat.github.io/WebGL-Fluid-Simulation/), если вы еще не знакомы. В учебном проекте все нужно делать без использования сторонних библиотек, но это популярный инструмент, про который стоит знать.

:heavy_plus_sign: - Для общего развития будет полезно написать свою рисовалку [множества Мандельброта](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%9C%D0%B0%D0%BD%D0%B4%D0%B5%D0%BB%D1%8C%D0%B1%D1%80%D0%BE%D1%82%D0%B0) на WebGL. Эта технология просто создана для рисования подобных фракталов. На примере такой программы можно будет попрактиковаться в разных вещах - там и геометрические расчеты для зума и перемещения камеры, и генеративные цветовые схемы, можно анимации какие-нибудь прикрутить. В общем это может быть неплохой площадкой для экспериментов. А эксперименты дают понимание, как все работает.


### :lock: 6.01 (про отладку света, тени и компьютерную графику)

:point_up: - При отладке света на сцене может быть хорошей идеей сделать источники света разноцветными. Например один ядрено-зеленым, другой ядрено-розовым и.т.д. Это позволит лучше видеть световой рисунок на сцене и будет проще подобрать параметры для источников света.

:point_up: - Также на время разработки можно подключить OrbitControls, чтобы крутить сцену и видеть ее с разных сторон. Это может быть полезно и при отладке света, и при расстановке объектов на сцене.

:heavy_plus_sign: - Полезно при изучении разных штук в рамках Three.js обращать внимание и на то, что скрыто внутри них. Это – библиотека, набор готовых решений каких-то задач из мира компьтерной графики, и хорошо знать, что там происходит внутри. Не только для общего развития кругозора, но и для понимания, что и почему может повлиять на производительность, куда смотреть, если на экране появляются какие-то артефакты и.т.д. Например понимание алгоритмов, как рассчитываются тени от точечных источников света, может дать ответы на вопросы о том, почему много источников света с тенями – это беда для телефонов и встроенных видеокарт, или почему границы теней вдруг пошли квадратиками и что с этим делать. Все это выходит за границы курса, но если вы хотите погрузиться в саму предметную область и решать задачи, выходящие за рамки примеров из документации – читайте больше статей и книг по компьютерной графике. Все, до чего руки доберутся. И, что важно - от разных авторов, с разными специализациями. Математики, физики, программисты - каждый будет давать вам что-то от себя, свой контекст задач, формируя разностороннее видение отрасли, хотя по сути все книги будут про одно и то же. Конкретные инструменты меняются, но общие принципы формирования того же 2D изображения из 3D сохраняются десятки лет. Видимое развитие компьютерной графики за последние 20 лет больше связано с тем, что появились доступные широкому кругу людей вычислительные мощности, которые могут в реальном времени что-то там расчитать, чем с серьезными изменениями в математических основах. Там все происходит очень неспешно.


### :lock: 6.02 (про библиотеку моделей и материалов)

:heavy_plus_sign: - В таких проектах часто идут по пути создания отдельной библиотеки моделей, текстур, материалов и.т.д. Она в начале инициализируется сама в себе, а потом все сцены из нее берут только то, что им нужно. Это помогает и не делать несколько раз одно и то же в разных сценах, и разделяет код проекта на логические части, его проще понимать, и за процессом загрузки следить удобнее (прелоадер тот же самый с процентами - намного проще сделать, чем если код создания всех моделей и материалов будет размазан по всему проекту). Здесь будет много заданий про загрузку моделей разными способами и может быть полезно подумать над разными способами организации всего этого кода.


### :lock: 6.06 (про расширение материалов)

:point_up: - По всей видимости формулировка задания путает, но то, что вы сделали - это не совсем то, что нужно. Ваши шейдеры дают вам только текстуру на поверхности объектов. Это работает. Но по идее нужно туда же интегрировать всю логику работы материалов, которая уже есть в Three.js (свет, тени, отражения и.т.д.). Смысл расширения материалов именно в том, чтобы совместить готовое с дополнительной функциональностью, а в вашем случае получается, что вы делаете материал, в котором есть ваша логика, но полностью отсутствует логика из стандартных материалов. У вас в целом все получается, так что задание будет формально принято, но с напутствием разобраться в этой теме.

:heavy_plus_sign: - Полезно познакомиться с альтернативным решением, не упомянутом в учебнике: у материалов есть [onBeforeCompile](https://threejs.org/docs/#api/en/materials/Material.onBeforeCompile), можно прямо перед компиляцией шейдеров для материалов их модифицировать, в частности интегрировать туда свои шейдерно-сгенерированные текстуры, [например вот так](https://codepen.io/sfi0zy/pen/XWerBEM).

:heavy_plus_sign: - Для расширения кругозора можно познакомиться с еще одним решением этой задачи: если нужно сгенерировать текстуру и при этом воспользоваться стандартными свойствами материалов из Three.js (тени, блики и.т.д.), и если текстуру сложно сообразить в рамках одного шейдера, то можно все нарисовать на отдельном канвасе, в том числе на 2D, и использовать его как текстуру, [например как в этой демонстрации](https://codepen.io/sfi0zy/pen/NQOdGd). А еще так можно выводить видео на поверхность модели. А в теории можно и результат, полученный после выполнений шейдеров, сохранять и переиспользовать в других шейдерах, или даже в тех же самых. Но к этому мы еще вернемся в будущем. Важно понять идею, что текстура - это понятие очень растяжимое, по сути это картинка, а картинки можно переиспользовать в самых разных комбинациях.


### :lock: 6.07 (про оптимизацию моделей)

:heavy_plus_sign: - В целях общего развития может быть полезно взять какой-нибудь 3D-редактор, например [Blender](https://www.blender.org/) (он бесплатный и кроссплатформенный), и посмотреть на то, как устроены сложные модели:

![](https://habrastorage.org/webt/kd/cr/_g/kdcr_gim0p3ttq3gfyc-2wetv1g.jpeg)

:heavy_plus_sign: - На примере самолета из курса можно посмотреть пример модели, которую в контексте фронтенда нужно бы отправить на доработку. Количество вершин здесь можно уменьшить на порядок, без какого-либо влияния на видимый результат. Например такая детализация окон нам в проекте точно не нужна - самолетик слишком маленький, чтобы что-то там разглядеть. По идее нам нужно стремиться к использованию low poly моделей и этот факт в требования нужно закладывать сразу, еще до создания моделей. И на этом моменте можно улучшить не только размеры модели (и скорость ее загрузки по сети), но и общую производительность, т.к. значительно снизятся требования для видеокарты. Мне встречались проекты, где только оптимизация моделей позволяла увеличить средний fps на сайте с 2-3 кадров до 30-40 на ноутбуке с обычной UHD Graphics.


### :lock: 6.09 (про отладку и FPS)

:heavy_plus_sign: - В проекте постепенно накапливаются вопросы по части производительности. Будет полезно узнать, что стандартные инструменты разработчика, например FPS-meter в Chrome, могут сильно привирать при работе с канвасом. По их показаниям может казаться, что все хорошо, но глазами видно, что это не так. Или наоборот - все работает хорошо, а инструмент говорит, что все плохо. Здесь все так же, как и с PageSpeed Insights, если вы понимаете, о чем я. В основном причины этого кроются в том, что у нас из браузера не так много (фактически вообще нет) возможностей получать полную и достоверную информацию о происходящем на видеокарте. В качестве альтернативы FPS-meter можно сделать какое-нибудь свое решение или взять [stats.js](https://github.com/mrdoob/stats.js/). Кажется, что это самый популярный инструмент для отображения FPS среди разработчиков, связанных с Three.js.

:point_up: - У вас в критерии Б1 говорится, что анимация должна быть сделана без сторонних библиотек, но здесь речь именно про отладку, это можно потом убрать перед защитой.


### :lock: 7.07 (про оптимизацию для телефонов)

:heavy_plus_sign: - Вообще подобные "оптимизации" при работе с WebGL действительно в теории дают какой-то прирост производительности, но на практике для пользователя часто разницы никакой - оно как тормозило, так и тормозит. И, разумеется, у нас здесь не игровая индустрия, мы не можем задать минимальные системные требования для сайта. Подобные оптимизации обычно имеют смысл только при доведении до идеала того, что и так работает хорошо. Отчасти по этой причине мне кажется хорошей идеей подобные проекты делать всегда в обратную сторону - начинать с прототипа трехмерной части, смотреть, насколько она работоспособной получается, и уже потом, если все ок, верстать все остальное. Ну а если не ок, то это обнаруживается сразу, а не перед дедлайном, и есть возможность поменять концепцию, заменить 3D на видео, или вообще от него отказаться в пользу каких-то 2D-эффектов в том же стиле. Не стоит надеяться на то, что любую сцену можно сделать производительной или что получится оптимизировать то, что явно тормозит, при этом сохранив изначальную концепцию и более-менее красивую картинку.


### :lock: 7.09 (про постпроцессинг и баги буфера глубины)

[ СКРИНШОТ ПРОЕКТА СТУДЕНТА (АНАЛОГИЧНАЯ КАРТИНКА ДЛЯ ПРИМЕРА) ]

![](https://habrastorage.org/webt/3n/dj/lg/3ndjlgwnetjbrplvrzjoy1fbk8m.jpeg)

:point_up: - В данном случае проблема проявилась в последнем Хроме под линуксом с графикой UHD Graphics 605, хотя могла проявиться и где-нибудь еще, например в Safari.

:point_up: - WebGL опускает нас к более низкому уровню работы с железом, мы уже не находимся в привычной песочнице javascript, в которой от железа не зависит почти ничего. И у разных браузеров на разном железе могут быть разные ограничения, например на максимальный размер текстуры или карты теней. По-хорошему проекты с WebGL нужно тестировать не только в разных браузерах, но и на разном железе (хотя, конечно, бюджет не всегда это позволяет). Плюс библиотека Three.js, если уж мы ее используем, накладывает сверху свою логику, в которой тоже есть не самые очевидные wtf-моменты, например добавление постобработки меняет то, как основной рендерер работает с буфером глубины и может произойти то, что видно на скриншоте. В данном случае вопрос можно решить, если руками включить логарифмический буфер глубины у рендерера. Это даст минус к производительности, но плюс к надежности. И это хороший пример ситуации, когда знания из области компьютерной графики нужны не просто на словах. Пошли артефакты по экрану, проектом невозможно пользоваться, и при этом проблему очень сложно загуглить - инструменты разработчика не дают абсолютно никакой информации. Догадаться о том, что что-то не так с буфером глубины можно только если знать, что это такое, и как он работает.


### :lock: 8.01 (про розовые очки)

:heavy_plus_sign: - К последнему заданию на курсе повторю мысли о суровой реальности: мы можем запустить Unreal Engine в браузере, даже вес страницы – не такая проблема (сериалы мы смотрим как-то и не жалуемся), но вычислительные мощности, необходимые, чтобы завелся серьезный проект на таком движке, очень некислые. Это будет не рендеринг видео на ночь, это будут задачи в реальном времени. Нужна хорошая видеокарта. Будет ли она у каждого нашего клиента? Вероятнее всего нет. Минимальные системные требования для сайта – такое себе решение. Очень редко мы можем их ввести без потери клиентов, это должен быть какой-то узкоспециализированный бизнес, который рассчитывает, что у клиентов будет нужное железо, или даже сам им его организует. Это же можно сказать не только про вычислительные мощности, но и про поддержку разных штук браузерами. Например WebGPU упоминают в вакансиях уже несколько лет, рассказывают красивые сказки про замечательное API (это как бы правда - после WebGL смотреть на WebGPU приятно), но по факту [все очень печально](https://caniuse.com/webgpu). Технология WebGL2 хоть и [выглядит получше](https://caniuse.com/?search=webgl2), но еще пару лет назад вызывала много вопросов по части надежности. Только получившая "зеленую" поддержку технология была откровенно сырой, с кучей сложноисправляемых и абсолютно не гуглящихся багов. Стоит серьезно думать, прежде чем притягивать такого рода технологии в проект - исправить решение на стадии глубокой разработки будет очень непросто. При изучении теоретически возможных инструментов и подходов в будущем – обращайте внимание на то, насколько они вписываются в реальность здесь и сейчас.

