# Типичные советы по CSS


Здесь собираются типичные советы по CSS.


## Базовые критерии

### Б21

:red_circle: - Явно указывайте начальное и конечное значения для анимации в keyframes (критерий Б21).

:point_up: - Это упрощает понимание происходящего, когда анимаций становится действительно много и требуется отладка. Нет нужды ходить каждый раз, искать, где же анимация применяется, и высматривать там ее составляющие. А еще эти составляющие порой разные в разных компонентах оказываются, и от такой невнимательности может начинаться магия. Когда все в одном месте - думать проще, ошибок меньше.


## Ситуативные советы

### Про производительность transform

:point_up: - С точки зрения производительности лучше отдавать предпочтение свойству `transform`. Более подробно тема производительности в CSS разбирается во втором модуле учебника, но если в двух словах, то лучше все, что есть, анимировать меняя свойства `transform` и `opacity`, т.к. они менее склонны вызывать перерисовку всей страницы. Не всегда решение очевидно с первого взгляда, но это вопросы больше из области верстки, а не анимаций.

:bulb: - Может быть полезно завести себе в привычку сразу верстать разные состояния компонентов интерфейса так, чтобы они отличались только по этим свойствам, или по крайней мере стремиться к этому. Если верстку делает кто-то другой, то можно требование использовать эти свойства заранее включить в ТЗ. Это простой способ предотвратить рост технического долга по части производительности в нашем текущем контексте. Главный подводный камень тут в том, что проблемы с производительностью, заложенные в таких анимациях, имеют накопительный эффект. Чем больше одновременных анимаций и чем больше страница - тем сильнее они будут проявляться. И не всегда можно заранее предсказать, где те или иные компоненты будут использоваться. В результате может получиться пожар из разряда тех, что проще предотвратить, чем потушить. Думаю вы видели такие интернет-магазины, которые чуть ли не вешаются при открывании какой-нибудь менюшки - это именно оно. Схожий эффект может дать постоянное залезание в DOM из скриптов и совершение операций, которые вызывают перерисовку страницы в той или иной степени. Там тоже легко закрыть на это глаза на простой странице, но по мере роста проекта проблемы с производительностью будут усугубляться аналогичным образом. В некоторых особо сложных случаях делу может помочь свойство `contain`, но оно не решает проблему с перерисовкой страницы полностью, оно лишь помогает ее локализовать. Иногда этого достаточно, чтобы страница перестала тормозить, иногда - нет.


### Про REM и адаптивность CSS

:point_up: - Весь макет сверстан в единицах rem, которые привязаны к размеру экрана. Фиксированные значения в px могут разойтись с ними и привести к багам или странным движениям на определенных размерах экрана. Лучше продолжать использовать rem. Если все же нужны пиксели, то стоит все проверять много раз на всех возможных размерах экранов - такие нестыковки легко пропустить.

:bulb: - Если вы раньше не сталкивались с версткой на плавающих размерах шрифта и с CSS-шлюзами, то будет полезно познакомиться с [хорошей статьей](https://www.smashingmagazine.com/2016/05/fluid-typography/) по теме.

:bulb: - В целом при работе с CSS-анимациями очень важно обращать внимание на адаптивность. И, как ни странно, именно выбор единиц измерения часто будет отделять хорошо проделанную работу от глючного поделия, которое придется переверстывать, потому что оно рассыпается при малейшем изменении размера экрана. На появлении текста из прозрачности мы можем не заметить, что что-то поехало и логика анимации изменилась, но когда компоненты становятся более комплексными - проблемы становятся очевидными для всех вокруг. Обычно хорошей идеей будет выбор единиц измерения в соответствии с логикой в дизайне. Линия в 1 пиксель, смещение на высоту буквы (em/rem), увеличение от 0% до 100%, вписывание чего-то в размер окна (vh, vw, vmin, vmax) - там часто будет простое человеко-понятное описание происходящего. И его можно перенести в CSS с помощью местных единиц измерения. Поначалу такой подход может показаться требующим больших мыслительных усилий, чем тупая копипаста пикселей везде, или нагромождение media-выражений на каждый чих, но в долгосрочной перспективе мы экономим кучу времени на исправлениях и подпорках, чтобы все хоть как-то работало.


### Про глаголы в названиях действий

:point_up: - Будет хорошей идеей использовать глаголы в названиях анимаций, чтобы подчеркнуть действия, которые в них происходят (мы то же самое делаем в скриптах для функций). Это очень поможет с восприятием кода, когда анимаций станет на самом деле много.


### Про fadeIn, fadeOut и коллизии имен

:point_up: - Для таких универсальных анимаций есть общепринятые названия вроде fadeIn, fadeOut, fadeInLeft, fadeInRight и.т.д. Есть популярная библиотека [animate.css](https://animate.style/) в которой они все собраны. Если вы будете придерживаться этих названий - ваш код будет проще понимать вашим коллегам, не нужно будет думать, что делает та или иная анимация. По крайней мере познакомиться с этой системой названий точно стоит.

:bulb: - Все keyframes попадают в одну область видимости. Рано или поздно начнутся коллизии имен. В проектах с хитрыми системами сборки, которые под каждую страницу собирают и оптимизируют что-то свое, а потом все вокруг кешируется, такие коллизии может быть на удивление долго искать и исправлять. Мы в какой-то момент просто не понимаем, откуда взялись те или иные анимации. Это можно решить либо путем изоляции стилей (как минимум - сделать префиксы для всех анимаций из имен компонентов, к которым они относятся, как максимум - автоматизировать генерацию рандомных префиксов), либо путем того, что вынести анимации в отдельное место, библиотеку анимаций, и сделать их частью единой дизайн-системы в рамках всего проекта/компании. Часто в простых дизайнах идут именно по второму пути. Мы имеем файл, в котором есть полный набор всяких fadeIn, fadeOut, и.т.д., они везде переиспользуются и нигде не дублируются. В проектах более сложных, или где много людей, чаще склоняются к изоляции стилей. Это проще организовать задним числом. Ну и, если дизайн сильно экспериментальный, то переиспользовать особо ничего не получится. В любом случае имейте в виду, что проблема коллизий имен существует, и тут может иметь смысл заранее ее предотвратить, пока кодовая база не очень большая.


### Про туда-сюда

:point_up: - Для решения задачи анимирования "туда-сюда" можно использовать кривую Безье, которая немного выходит за пределы квадрата 1 на 1. Современные браузеры уже давно умеют такое делать. Как пример - [cubic-bezier.com/#.6,-0.25,.34,1.51](https://cubic-bezier.com/#.6,-0.25,.34,1.51).


### Про не туда-сюда

:point_up: - Будьте осторожны с такими значениями больше 1 или меньше 0 в кривых Безье, в ситуациях, когда это не задумано изначально как движение туда-сюда. Эти значения могут создать лишнюю точку перегиба кривой, и из-за нее может появиться плавающий баг, когда в конце движения элемент прыгает немного назад. Или в начале будет двигаться не туда. Такое легко пропустить при тестировании, это может быть артефакт в 1px, но он потом где-нибудь в продакшене всплывет и будет резать глаз.


### Про анимации в контексте страницы

:point_up: - При работе с CSS анимациями важно следить за тем, чтобы они не ломали верстку вокруг себя. Анимации на одних элементах могут смещать другие, провоцировать появление скроллбаров от переполнения чего-то, давать изменения в размерах элементов в 1px (артефакты округления), которые заметно портят общее впечатление от интерфейса, могут просто скрывать за собой другие анимации или перебивать их стили, могут расходиться с изначальными состояниями компонентов, и.т.д. Помните о том, что анимации существуют не в вакууме, и всегда проверяйте, что они работают нормально после внедрения в реальный интерфейс.


### Про одновременные transition и animation

:point_up: - Такие места, где одновременно применяются и transition, и animation, должны настораживать. Это красный флаг, за который глаз должен цепляться. Потенциально опасное место. Обычно это означает, что либо там одновременно выполняются разные анимации, что потенциально может привести к артефактам и всегда требует тщательного тестирования в разных браузерах, либо там есть какие-то грязные хаки, которые кто-то не задокументировал. Конкретно здесь наличие и transition, и animation, выглядит избыточно. Стоит проверить, а действительно ли в текущем контексте нужно и то, и другое.


### Про !important

:point_up: - Не злоупотребляйе с !important в анимациях. Эта штука очень редко на самом деле нужна, а вот проблем на ровном месте создать может. Здесь компоненты простые, так что это может быть не очевидно, но по мере усложнения верстки избыточные !important могут стать головной болью.


### Про логические состояния и классы в CSS

:point_up: - Логическое состояние компонента может разойтись с тем, что по факту происходит на экране. Это не совсем про анимации, но проблема распространенная в нашем контексте, так что стоит сказать пару слов. Обычно такие истории начинаются либо если один компонент создается более одного раза и его экземпляры начинают параллельно что-то делать, противоречить друг другу на одних данных, либо если логика завязывается на какие-то внешние следствия самой себя. Например если у нас есть состояние компонента, и CSS-классы навешиваются в зависимости от этого состояния, то у нас односторонняя связь. Все должно работать предсказуемо. А если классы навешиваются в зависимости от состояния, а потом состояние меняется в зависимости от классов - получается циклическая зависимость. А поскольку у нас в JS не все операции выполняются последовательно - можно получить полнейший раздрай в интерфейсе. Всегда лучше иметь явное состояние.


### Про точку входа

:point_up: - Обычно в таких сценах удобно иметь один контейнер, размер которого задается в зависимости от дизайна, а все, что внутри него, делать в процентах. Одна точка входа в сцену сильно упростит жизнь при необходимости адаптировать ее к разным размерам экранов. Меняем размер контейнера - все само адаптируется. Если завязать все внутри сцены на пиксели или какие-то другие фиксированные внешние значения - сцену будет сложно масштабировать. Эта идея с одной точкой входа, от которой зависит все, будет повторяться в самых разных обстоятельствах в дальнейшем, не только в вопросах размеров, но и касательно времени начала анимаций, обновления данных в сценах и.т.д. При изучении различных инструментов имеет смысл обращать на эту идею внимание, где она там может пригодиться. Часто она позволит сильно упростить работу не прикладывая никаких особых усилий.


### Про color и конкретный цвет

:point_up: - В реальных сайтах часто бывает много цветов, может быть больше одной цветовой схемы, и идея с именованием color = конкретный цвет в контексте появления текста из прозрачности обычно работает не очень. Она быстро превращается в fadeInColor1, fadeInColor2, fadeInAccentColor, fadeInAccentColor2InDarkColorScheme и.т.д. Там могут быть десятки анимаций, почти одинаковых, но не совсем. Часто более удобным для поддержки решением будет использование одного fadeIn, никак не завязанного на цвет, для всего, пусть и ценой добавления оберток для текстов в некоторых элементах интерфейса. А с приходом в нашу практику CSS custom properties появилась и возможность делать анимации с их использованием - можно иметь у текстов наборы свойств для начальных/конечных цветов и одну анимацию, которая "сама адаптируется" к цветовому контексту. Этот вариант требует большей изначальной подготовки, но такое тоже иногда бывает уместно.



## Советы, закрепленные за конкретными заданиями

### :lock: 1.01 (про анимации в отдельном файле и анализ)

:bulb: - В рамках курса у нас есть второй проект - "Иллюзион". Там практически весь код, связанный с CSS-анимациями [вынесен в отдельный файл](https://github.com/htmlacademy-animation/illusion/blob/master/source/sass/animation.scss). Альтернативно можно этот код поделить и хранить в файлах самих компонентов, к которым он относится. Предлагаю вам подумать, какой из этих двух вариантов организации кода будет удобнее и, главное, почему? Или может быть имеет смысл смешанный вариант? Не воспринимайте "эталонные" примеры как нечто единственно правильное. Возможны разные варианты. Раскритикуйте код Иллюзиона по полной программе и придумайте аргументы "за" и "против" предложенного там подхода с хранением кода всех анимаций в одном файле.

:bulb: - По мере прохождения курса мы будем затрагивать разные подходы к разным задачам, в том числе альтернативные учебнику, и будет хорошо, если вы уже сейчас начнете заниматься анализом того, что вы делаете. Какие есть классы задач? Какие есть классы инструментов? Почему что-то сделано так, а не иначе? Почему выбран именно такой инструмент? А какие еще есть варианты? Почему не вон тот инструмент? Почему? Почему? Почему? Анализируя контекст вы не только будете глубже разбираться в том, что делаете вы или ваши коллеги, но и будете развивать способность к аргументации собственных профессиональных решений в контексте наших задач. Очень полезная штука. А я буду время от времени вас подталкивать к размышлениям, задавая какие-то вопросы или делая отсылки к альтернативным инструментам. По мере прохождения курса они будут накапливаться, и мы сможем дополнительно обсудить все это на консультациях. В идеальном варианте к концу курса мы сможем сформировать у вас разностороннее видение предметной области, чтобы вы не просто слепо повторяли "единственно правильные решения" или что-то, что "всегда так делали", а все же четко понимали, что вы делаете, в каком контексте, и с какой целью. Но придется много думать, без этого никак.


### :lock: 1.02 (про дизайн-токены)

:bulb: - Если у нас в проекте есть дизайн-система, то вполне вероятно, что она включает в себя набор длительностей и временных функций для анимаций, [вроде того, что есть в Material Design](https://m3.material.io/styles/motion/overview) (полистайте раздел motion). К сожалению в учебном проекте такой системы нет, но тем не менее у вас в коде будут продолжать накапливаться повторяющиеся значения длительностей, задержек для анимаций и временных функций. И на самом деле в любом проекте они будут накапливаться. Может иметь смысл подумать над тем, как будет удобно организовать эти повторяющиеся значения. Со стороны дизайнера это может выглядеть как список значений с инструкциями, какие из них для каких ситуаций в интерфейсе должны применяться, а с нашей стороны - как набор констант препроцессора. Даже маленький шаг по созданию такого набора с инструкциями по использованию может существенно сократить количество согласований, правок, и необходимости что-то постоянно контролировать и подгонять.


### :lock: 1.03 (про переходы между экранами, про Barba.js)

:bulb: - Поскольку задача сделать плавные переходы довольно распространенная, будет полезно подумать о том, как строится логика таких переходов. Возможно вы уже работали с какими-то роутерами и все видели, но если нет, то подумайте, какие логические состояния есть у компонента "экран"? Сколько их? 1? 2? 4? Больше? Каков жизненный цикл экрана? Переход между экранами - это событие? Или может быть это растянутый во времени процесс с событиями начала и конца? Можем ли мы быть уверены в длительности этого процесса? А если экраны - это буквально разные страницы, которые подгружаются в процессе? Как стоило бы организовать модуль, который переключает экраны, чтобы можно было в явном виде связать состояния экранов и все наши анимации как появления, так и исчезания компонентов интерфейса?

:bulb: - По теме плавных переходов между экранами будет полезно дополнительно познакомиться с библиотекой [Barba.js](https://barba.js.org/), если вы еще не знакомы. В учебном проекте все нужно делать без использования сторонних библиотек, но это популярный инструмент, про который стоит знать.


### :lock: 2.01 (про промышленный дизайн и видео-концепты)

:point_up: - Обратите внимание, что в видео-концепте логика работы анимации кружков другая. Кружок увеличивается, а цифра в нем - нет. По сути логика работы этих кружков такая же, как у кнопки соц сетей. Хотя у нас нет полноценной дизайн-системы, но тут прослеживается последовательность в дизайне компонентов. Это хороший пример ситуации, когда в наши руки попадает верстка от других разработчиков и она не совсем соответствует дальнейшей логике, что с ней нужно делать. Здесь нам определенно нужно иметь два элемента, один для кружка, а другой для цифры. А наш теоретический коллега-верстальщик сделал только один. Придется исправить. В реальной работе при составлении ТЗ на верстку может иметь смысл заранее туда включать какие-то требования по поводу разделения вещей на несколько элементов. Тут все очень ситуативно и зависит от дизайна, но стоит про такой момент знать. Иногда такие уточнения ТЗ с нашей стороны экономят кучу времени и избавляют от выполнения двойной работы.

:bulb: - Получение длительностей и угадывание временных функций из видео при работе над интерфейсами – в некоторой степени сомнительная затея. В рамках учебного курса, как упражнение - ок. Развиваем глазомер, так сказать, учимся видеть детали. Но в реальной работе этим заниматься не стоит - слишком уж много времени уходит на что-то, чем можно вообще не заниматься. Обычно мы можем организовать процессы так, чтобы исключить саму идею подбора чего-то из видео. Это упростит работу всем вокруг. Дизайн интерфейсов – это же больше промышленный дизайн, чем искусство. Все должно быть по возможности унифицировано для уменьшения издержек на производстве. Если анимации имеют разную длительность – это должно быть логически обосновано. Если разные временные функции – тоже. Так или иначе мы приходим к ограниченной дизайн-системе (даже если ее изначально нет в проекте, то мы ее можем создать), и все длительности, задержки и временные функции берутся из нее. В таком контексте видео-концепты становятся просто способом показать суть движений, когда их сложно описать словами. Видео не нужно рассматривать как эталон, к которому нужно что-то подгонять по времени.

:bulb: - Если все же возникает желание/необходимость посмотреть видео по кадрам (например если дизайнеры нашли какое-то видео в интернете и там какое-то хитрое движение, и его нужно разглядеть получше), то это может быть удобно делать в программах, предназначенных для редактирования видео. Если вы еще пользуетесь плеером с одной кнопкой на страницах учебника - попробуйте альтернативные варианты, чтобы посмотреть, как оно может выглядеть. Там есть разные программы, сам я обычно использую [Blender](https://www.blender.org/) для таких исключительных ситуаций, потому что он и так используется для работы с 3D, и получается все в одном месте.


### :lock: 2.02 (про левые пробелы и выбор инструментов)

:bulb: - В таких скриптах в реальных проектах часто практичнее разбивать все регулярным выражением, завязанным на whitespace, а не вот так, особенно если контент делает кто-то "не в теме" и может воткнуть странные пробелы, табы, переносы строк, и.т.д.

:bulb: - В 99% подобных анимаций рандомные задержки, или какие-то еще рандомные штуки - рандомные. По логике своей. Их не нужно подбирать. Если у вас возникает мысль "а не подобрать ли мне сотню случайных значений из видео" - скорее всего этого делать не нужно. Часто гораздо быстрее и проще у дизайнера в чате спросить "а это по смыслу случайные штуки?", получить ответ "да", и воткнуть в нужное место Math.random() или что-то такое, но не подбирать такие значения. Может быть нужно будет ограничить максимальные и минимальные значения, или задать общее направление движения, если оно там есть, но не более того. Этого будет достаточно, чтобы сохранить характер анимации.

:bulb: - Для общего развития по теме рандомизации всего и вся будет полезно загуглить про генераторы 1D, 2D и 3D шума. Идеи из них очень часто используются на подобных сайтах в самых разных задачах, где нужно что-то "случайное, но не совсем". В частности [шум Перлина](https://ru.wikipedia.org/wiki/%D0%A8%D1%83%D0%BC_%D0%9F%D0%B5%D1%80%D0%BB%D0%B8%D0%BD%D0%B0) - это очень популярный алгоритм, про который стоит знать.

:bulb: - В разработке подобных сайтов часто возникает задача сначала загрузить кастомные шрифты, а уже потом что-то там с ними анимировать. Будет полезно положить себе в закладки [Web Font Loader](https://github.com/typekit/webfontloader), или какой-нибудь аналогичный инструмент. Да и в целом в дальнейшем имеет смысл обращать внимание на то, как загружаются разные ресурсы, и каким образом можно отслеживать момент загрузки. Тут проект учебный, это может быть не так важно, но в реальной работе имеет смысл сразу всю логику завязывать на явные события загрузки ресурсов и сразу проводить тестирование с имитацией "медленного интернета", потому что когда-то потом оно обязательно забудется и всплывет в продакшене, когда заказчики или клиенты начнут жаловаться.

:bulb: - По мере прохождения курса мы будем затрагивать еще такую тему, как управление рисками. Некоторые решения, которые лежат на наших плечах, могут приводить к дорого решаемым проблемам, и было бы хорошо обратить на них внимание до того, как вляпаться. И первой мыслью для обдумывания будет то, что не все инструменты достаточно гибкие в контексте анимаций и каких-то странных дизайнов в целом. В случае с учебным проектом мы имеем такой инструмент, как Swiper. Модный слайдер, популярный выбор во многих компаниях. Но. Не всегда сторонние инструменты будут предполагать, что в них будут внедряться анимации с той или иной логикой работы. Часто популярные инструменты, которые хороши из коробки, плохо кастомизируются. И этот самый Swiper - один из сложных в адаптации слайдеров. На Хабр Q&A люди регулярно приходят с вопросами, а как в него внедрить ту или иную дизайнерскую задумку. И количество костылей и подпорок в решениях порой поражает воображение. Да и в своей практике я могу вспомнить ситуации, когда я тратил дни на то, чтобы привести построенную вокруг него глючную верстку к требованиям дизайнера. В этом курсе инструменты выбраны за вас, но в реальных проектах - выбирайте сами и с умом. Лучше десять раз погуглить, чем один раз влипнуть. Решения, связанные с выбором инструментов, порой сложно отменить в будущем, а из-за одного необдуманного выбора работа может сильно усложниться на ровном месте.

:bulb: - Продолжая тему осознанных выборов: в проекте у вас есть задания, связанные с созданием сценок-мультиков. Можно их делать по-разному - там и CSS, и SVG, и на канвасе потом будет, можно менять CSS и SVG из скриптов, есть Web Animations API. Да и в целом в мире полно сопутствующих инструментов, которые дают какие-то еще дополнительные возможности. Думаю, что на текущем этапе должно быть очевидно, что вариант с чистым CSS - не самый удобный. Что-то сделать можно, но и ограничения есть. Может быть хорошей идеей по мере прохождения курса сравнить разные подходы к этому классу задач и отметить для себя, в чем разница между ними, какие уникальные возможности или ограничения есть у разных инструментов (плюс я там потом еще от себя добавлю про контекст, в котором они возникают, и альтернативные инструменты).

### :lock: 2.03 (про Locomotive Scroll, длину окружности, процессы разработки)

:bulb: - По теме CSS-анимаций будет полезно дополнительно познакомиться с библиотекой [Locomotive Scroll](https://locomotivemtl.github.io/locomotive-scroll/), если вы еще не знакомы. В учебном проекте скролла нет, но это популярный инструмент, про который стоит знать.

:bulb: - Для общего развития может быть полезно освежить в памяти школьную геометрию ([планиметрию](https://ru.wikipedia.org/wiki/%D0%9F%D0%BB%D0%B0%D0%BD%D0%B8%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%8F) в первую очередь) и физику ([механику](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D0%BA%D0%B0) в первую очередь), если вы еще этого не сделали. В разных задачах про вкатывания, падения с отскоками и другие условно физически правильные движения не всегда получается угадать нужные комбинации смещений и поворотов, чтобы все выглядело естественно. И тогда эти знания приходят на помощь. В случае со скриптами мы можем буквально подставлять формулы из справочников в код и получать натуральные движения с человеко-понятными коэффициентами, а в случае с CSS - мы можем по крайней мере точно посчитать комбинации значений. Далеко ходить не нужно - вкатывание круглой кнопки. Здесь ее смещение и угол поворота непосредственно связаны через радиус и формулу длины дуги окружности, и можно точно подогнать одно под другое. Понятно, что в такой простой задаче и угадать значения можно, но не все задачи будут простыми. Не обязательно погружаться в какие-то дебри и строгие доказательства теорем, но определенно имеет смысл полистать на досуге википедию или какой-нибудь справочник для поступающих в ВУЗы, чтобы иметь общее представление о том, что там бывает, и потом при случае не изобретать велосипеды, а воспользоваться готовыми знаниями.

:point_up: - Комментарий про геометрию в частности про эту кнопку. Тут значения смещения и поворота связаны через число π, и такой красивой ровной комбинации тут быть не может. Движение короткое, поэтому это может быть не совсем очевидно, но если кратно увеличить все, то можно будет заметить, что кнопка катится не совсем естественно. Есть элемент проскальзывания.

:bulb: - И в завершение части курса про CSS, будет хорошо поднять тему последовательности разработки проектов, подобных учебному, с точки зрения управления рисками. Вы идете по условным темам CSS/SVG/canvas/WebGL, которые поставили "по возрастанию сложности". Но в реальной работе если начать с верстки, а WebGL оставить на конец – мы можем с разбега влететь в большие неприятности. Дело в том, что есть задачи, которые мы можем решить со 100% вероятностью в разумные сроки. CSS-анимации из их числа. Такие задачи даже можно переделегировать менее опытным коллегам в случае нехватки времени. А есть вещи, которые мы вообще не можем решить в технической плоскости. Только в организационной. Не потому, что мы глупые или чего-то не знаем, а потому, что мы работаем в реальном мире, и у пользователей просто может не быть железа, которое вытянет графику того уровня, которую заложили в концепт сайта. И если это обнаруживается в самом конце, перед дедлайном – проект загорится. Если же мы сначала все проверили, попробовали сделать прототип самой подозрительной в этом плане части, и увидели проблемы, то у нас есть еще дни, а может и недели, чтобы переделать 3D-модели, поменять в каких-то пределах концепцию сайта или сами технологии (отказаться от рендеринга 3D в реальном времени в пользу каких-то других решений например). А уж верстку мы параллельно этому доделаем, не вопрос. В идеальной ситуации мы должны консультировать дизайнеров по вопросам реалистичности концептов еще до их согласования, но, понятное дело, что тут нужен опыт, который появится не сразу. Мы еще будем возвращаться к теме процессов по мере прохождения курса, а пока – подумайте над тем, что иногда практичнее сначала организовать какие-то процессы, подготовить все к работе, а уже потом идти в свою IDE и писать код. В следующем модуле это может сэкономить время.

