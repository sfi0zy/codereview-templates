# Типичные советы по Canvas


Здесь собираются типичные советы по Canvas.


## Базовые критерии

### Б27

:red_circle: - Частота анимации цифр должна быть уменьшена для снижения нагрузки на процессор (критерий Б27).

:point_up: - Критерии оценки - это формальность. Для нас здесь важно научиться ограничивать нагрузку на железо там, где она не нужна. Это одна из важнейших вещей, на которые нужно обращать внимание при работе с анимациями во фронтенде.


## Ситуативные советы


### Про таймер и центр масс

:point_up: - Обратите внимание, что левый край таймера, где цифры почти не меняются, дергается влево-вправо. Такого быть не должно. Если неизменяемый объект в анимации дергается - это всегда режет глаз. Часто можно это сгладить, зафиксировав его положение, и позволив дергаться изменяемым объектам. То же относится и к плавным перемещениям - если какой-то объект является "центром масс" анимации и стоит на месте - он должен стоять на месте, а не колебаться туда-сюда.


## Закрепленные советы


### :lock: 4.01 (про производительность)

:point_up: - Старайтесь всегда уменьшить количество лишних операций. В текущем контексте - обращений к DOM и перерисовок чего-то на канвасе. Таймерам, разного рода счетчикам, многим визуальным эффектам в большинстве случаев не обязательно дергать реальные элементы на странице 60 раз в секунду. Мы можем каждый кадр проверять, нужно ли обновление, и обновлять реальную страницу только при необходимости. Это уже хорошо скажется на общей производительности. И тут речь идет не только про время и какие-то интервалы, как было в учебнике, но и про любые данные, которые могут нуждаться в обновлении. Данные обновились - обновляем страницу, данные не обновились - ничего не делаем. В учебнике не делается сильного акцента на этом, но на практике лишние обращения к странице могут увеличивать нагрузку на железо в разы, а то и десятки раз. Сопутствующий момент: запуск и остановка анимаций из скриптов тоже всегда должны быть осознанными действиями. При запуске всегда стоит проверять, не была ли анимация уже запущена, т.к. повторный запуск того же самого увеличивает нагрузку на железо и может приводить к конфликтующим параллельным процессам, а если анимация пропала из области видимости, то ее можно остановить, чтобы не потребляла лишних ресурсов. Возможно вам покажется, что я тут говорю какие-то очевидные вещи, но люди на удивление часто недооценивают их влияние на работу сайтов, поэтому сделать акцент на них будет не лишним. Дальше, когда мы перейдем в мир WebGL - там эта же логика будет явно или не очень явно проявляться в контексте обновления координат объектов и матриц, с ними связанных, перекомпилирования шейдеров, и многих других операций. Можно обобщить это словами "нужно делать то, что нужно, и не делать то, что не нужно".


### :lock: 4.02 (про интерполяцию)

:bulb: - Будет полезно загуглить слово "[интерполяция](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D1%8F)". Если вы с понятием знакомы - это хорошо, но если нет, и вы пытаетесь угадывать подходы к решению задач - самое время познакомиться. Эта штука в компьютерной графике применяется на каждом шагу, в том числе и в анимациях. Буквально все JS-библиотеки для анимаций включают в себя интерполяцию значений во времени в том или ином виде, и хорошо понимать, что за всем этим на самом деле скрывается, и какие там есть варианты.

:bulb: - По теме будет полезно дополнительно познакомиться с библиотеками [Anime.js](https://animejs.com/) и [GSAP](https://greensock.com/gsap/), и сравнить подходы к организации кода анимаций у них, [в Иллюзионе](https://github.com/htmlacademy-animation/illusion/blob/master/source/js/modules/whale-canvas-animation.js), и в [демонстрации с моржом](https://up.htmlacademy.ru/animation/1/demos/5157) в учебнике (это единственная моя демонстрация в курсе). В учебном проекте все нужно делать без использования сторонних библиотек, но для собственного развития - будет хорошо посмотреть на одно и то же с разных сторон, и подумать над тем, как будет удобно организовать работу с разными временными функциями и сопутствующими параметрами в рамках JS.


### :lock: 4.03 (про разные варианты анимирования 2D сцен, производную, вспомогательные построения)

:bulb: - В учебном проекте есть несколько схожих по сути 2D сцен, которые анимируются с помощью CSS, SMIL, а теперь и с помощью скриптов тоже. Поэтому тут я напомню, что будет полезно сравнить эти варианты и подумать, когда будет предпочтительнее тот или иной подход и почему. И стоит дополнительно подумать о том, как такой выбор влияет на процессы в команде в целом. Очень здорово, когда в проекте, или даже в нескольких проектах, одинаковые задачи делаются одинаковым образом. Не нужно в голове контекст переключать, проще все интегрировать между собой, проще собрать заготовки на будущее - там люди могут разные аргументы придумать. В рамках учебного проекта мы имеем винегрет из технологий, чтобы был повод посмотреть на разные варианты, но в реальном мире обычно можно выбрать что-то одно.

:bulb: - Будет полезно загуглить слово "[производная](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)". В первую очередь нас тут интересует геометрический смысл производной и поиск касательной. Если вы с этим всем знакомы - замечательно, но если нет - самое время познакомиться. Задачи, связанные с поиском касательной к кривой или поверхности встречаются в нашей работе довольно часто - от поворота объектов при движении вдоль кривой, и до расчета реалистичного освещения в 3D. Помимо производных касательные можно искать вычисляя значения функции в двух точках в окрестностях нужной точки на кривой, и по ним получая вектор, параллельный ей. В 3D это будут 4 точки и два пересекающихся вектора соответственно. Этот подход более сложный для вычисления, он применяется в ситуациях, когда вся кривая или поверхность генерируется в реальном времени и мы не имеем возможности посчитать производные. В целом задача поиска касательной - это один из базовых кирпичиков, из которых мы собираем разные сложные алгоритмы, так что при погружении в мир компьютерной графики она будет одной из первых, требующих изучения.

:bulb: - И лайфхак из мира векторных графических редакторов (на случай, если вы еще им не пользуетесь): при работе с кривыми на канвасе может быть полезно делать вспомогательные построения, как [в этом примере](https://codepen.io/sfi0zy/pen/VwKgQPB). Соединять точки, по которым кривые строятся. Так будет гораздо проще понимать, что есть что, и что с чем связано. Особенно это выручает при необходимости составлять длинную кривую из множества коротких. Если вы еще так не делали - самое время попробовать. И графики функций для движений - их тоже можно рисовать на канвасе, вместо того, чтобы пытаться представить их в воображении.


### :lock: 4.04 (про инварианты)

:bulb: - Вы уже достаточно далеко продвинулись по курсу. Самое время начать думать об инвариантах в мире анимаций. Подумайте над тем, что вне зависимости от инструментов и технологий, будь то CSS, SVG, Canvas, какие-то библиотеки ко всему этому, мы так или иначе используем ряд более абстрактных терминов, которые имеют отношение к компьютерной графике в целом. В разных местах они могут называться по-разному, но суть у них одна и та же. Например маски на канвасе, в SVG, или clip-path в CSS - вроде бы это разные вещи, но если подумать - это одно и тоже в сути. С точки зрения конечного рендеринга страницы на экране - это почти одно и то же. [Временные функции](https://habr.com/ru/post/518006/) везде одни и те же. В CSS меньше выбор, чем в JS, но принцип работы тот же. Базовые трансформации - translate, rotate, scale, skew - одинаковые везде и строятся на одних и тех же [преобразованиях координат](https://habr.com/ru/post/520078/). Мы можем их по-разному описывать в коде, но суть решаемых задач от этого не меняется. И так со всем. Более того, вещи, которые плохо влияют на рендеринг страницы, вроде фильтров типа blur, или больших теней, будут одинаково плохо влиять и в CSS, и в SVG, и на канвасе, т.к. их принцип работы в конечном счете крутится вокруг одних и тех же алгоритмов. Подумайте над этим. В перспективе чем больше вы будете таких инвариантов для себя выделять, чем больше вы будете погружаться в базовые алгоритмы и принципы работы вещей, тем проще будет абстрагироваться от конкретных инструментов и решать задачи, которые вы до этого не решали, и предсказывать проблемы, которые еще не видели. Идея выделения инвариантов в предметной области сама по себе не новая, но полезно иногда о ней вспомнить и осмотреть свои знания на предмет наличия чего-то такого.

:bulb: - Для расширения кругозора может быть полезно познакомиться с проектом [Harmony](https://mrdoob.com/projects/harmony/). Это очень древняя штука, но подходы к решению подобных задач не устаревают. Исходники этого проекта [есть на GitHub](https://github.com/mrdoob/harmony/tree/master/src/js/brushes), и они достаточно простые для восприятия. Очень многие виды визуальных эффектов строятся на алгоритмах работы этих кистей.
