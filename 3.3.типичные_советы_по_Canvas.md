# Типичные советы по Canvas


Здесь собираются типичные советы по Canvas.


## Базовые критерии

### Б27

:red_circle: - Частота анимации цифр должна быть уменьшена для снижения нагрузки на процессор (критерий Б27).

:point_up: - Критерии оценки - это формальность. Для нас здесь важно научиться ограничивать нагрузку на железо там, где она не нужна. Это одна из важнейших вещей, на которые нужно обращать внимание при работе с анимациями во фронтенде. В контексте задания - старайтесь всегда уменьшить количество обращений к DOM. Таймерам, разного рода счетчикам, галереям картинок с эффектами и.т.д. в большинстве случаев не обязательно дергать реальные элементы на странице 60 раз в секунду.


## Ситуативные советы


### Про таймер и центр масс

:point_up: - Обратите внимание, что левый край таймера, где цифры почти не меняются, дергается влево-вправо. Такого быть не должно. Если неизменяемый объект в анимации дергается - это всегда режет глаз. Часто можно это сгладить, зафиксировав его положение, и позволив дергаться изменяемым объектам. То же относится и к плавным перемещениям - если какой-то объект является "центром масс" анимации и стоит на месте - он должен стоять на месте, а не колебаться туда-сюда.


## Закрепленные советы


### :lock: 4.02 (про интерполяцию)

:heavy_plus_sign: - Будет полезно загуглить слово "интерполяция". Даже если вы с понятием уже знакомы (а я надеюсь вы знакомы, а не случайно угадываете подходы к написанию кода), освежить все детали в памяти лишним не будет - эта штука в компьютерной графике применяется на каждом шагу. В контексте задания - заготовка значений для всех кадров заранее не всегда нужна. Для геометрических движений почти никогда не нужна. Например здесь - обычная линейная интерполяция значений во времени позволяет на ходу получать значения чисел для любого количества кадров, а не только фиксированного. Это должно быть понятно. Получается более гибкое решение по сравнению с заготовленными кадрами. А можно было бы сделать ее не линейной и замедлять счет или ускорять, при этом сохраняя понятное зрителю распределение чисел. Например при замедлении числа к концу менялись бы на все меньшие значения. Такие нелинейные анимации очень часто применяются во фронтенде - в том же CSS мы их постоянно используем. Более развернутый пример реализации интерполяций есть в моей демонстрации с моржом в учебнике (аналогичная мини-библиотека лежит в репозитории [weeee.js](https://github.com/sfi0zy/weeee)). Будет полезно один из этих примеров проанализировать и разобраться, как там все работает в своей сути. Буквально все JS-библиотеки для анимаций включают в себя этот функционал в том или ином виде, и хорошо понимать, что за ним скрывается.


### :lock: 4.03 (про разные варианты анимирования 2D сцен, производную, вспомогательные построения)

:heavy_plus_sign: - В учебном проекте есть несколько схожих по сути 2D сцен, которые анимируются с помощью CSS, SMIL, а теперь и с помощью скриптов тоже. Будет полезно сравнить эти варианты и подумать, когда будет предпочтительнее тот или иной подход. И не забывайте, что фундаментальные возможности и ограничения часто закладываются и в том, что анимируется, и в том, каким образом оно анимируется. Мы можем анимировать HTML-элементы с помощью скриптов, или SVG с помощью CSS, или, опять же, SVG с помощью скриптов. А еще есть Web Animations API, но это отдельная тема. Возможны разные комбинации со своими особенностями и будет полезно сравнить их, чтобы потом принимать решения при выборе инструментов более осознанно.

:heavy_plus_sign: - Будет полезно загуглить слово "производная". Даже если вы с понятием уже знакомы, освежить все в памяти лишним не будет. Не всегда будет легко угадать, на какой угол должен поворачиваться объект при движении вдоль кривой, заданной какой-то функцией (или системой, если речь про параметрические функции). А задачи такие бывают. Но посчитав производные можно будет найти уравнение касательной к графику функции в текущей точке, и подставляя одно и то же время в это уравнение и в исходное уравнение - получать точный угол поворота объекта в каждый момент движения.

:heavy_plus_sign: - И лайфхак из мира векторных графических редакторов (на случай, если вы еще им не пользуетесь): при работе с кривыми на канвасе может быть полезно делать вспомогательные построения, как [в этом примере](https://codepen.io/sfi0zy/pen/VwKgQPB). Соединять точки, по которым кривые строятся. Так будет гораздо проще понимать, что есть что, и что с чем связано. Особенно это выручает при необходимости составлять длинную кривую из множества коротких. Если вы еще так не делали - самое время попробовать. И графики функций для движений - их тоже можно рисовать на канвасе, вместо того, чтобы пытаться представить их в воображении.


### :lock: 4.04 (про Anime.js, GSAP, и инварианты)

:heavy_plus_sign: - По теме интерполяции значений в анимациях будет полезно дополнительно познакомиться с библиотеками [Anime.js](https://animejs.com/) и [GSAP](https://greensock.com/gsap/), и сравнить подходы к организации кода у них, в Иллюзионе, и демонстрации с моржом в учебнике. В учебном проекте все нужно делать без использования сторонних библиотек, но для собственного развития - будет полезно посмотреть на одно и то же с разных сторон.

:heavy_plus_sign: - Вы уже достаточно далеко продвинулись по курсу. Самое время начать думать об инвариантах в мире анимаций. Подумайте над тем, что вне зависимости от инструментов и технологий, будь то CSS, SVG, Canvas, какие-то библиотеки ко всему этому, мы так или иначе используем ряд более абстрактных терминов, которые имеют отношение к компьютерной графике в целом. В разных местах они могут называться по-разному, но суть у них одна и та же. Например маски на канвасе, в SVG, или clip-path в CSS - вроде бы это разные вещи, но если подумать - это одно и тоже в сути. С точки зрения конечного рендеринга страницы на экране - это почти одно и то же. [Временные функции](https://habr.com/ru/post/518006/) везде одни и те же. В CSS меньше выбор, чем в JS, но принцип работы тот же. Базовые трансформации - translate, rotate, scale, skew - одинаковые везде и строятся на одних и тех же [преобразованиях координат](https://habr.com/ru/post/520078/). Мы можем их по-разному описывать в коде, но суть решаемых задач от этого не меняется. И так со всем. Более того, вещи, которые плохо влияют на рендеринг страницы, вроде фильтров типа blur, или больших теней, будут одинаково плохо влиять и в CSS, и в SVG, и на канвасе, т.к. их принцип работы в конечном счете крутится вокруг одних и тех же алгоритмов. Подумайте над этим. В перспективе чем больше вы будете таких инвариантов для себя выделять, чем больше вы будете погружаться в базовые алгоритмы и принципы работы вещей, тем проще будет абстрагироваться от конкретных инструментов и решать задачи, которые вы до этого не решали, и предсказывать проблемы, которые еще не видели. Идея выделения инвариантов в предметной области сама по себе не новая, но полезно иногда о ней вспомнить и осмотреть свои знания на предмет наличия чего-то такого.

