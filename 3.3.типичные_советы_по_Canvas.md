# Типичные советы по Canvas


Здесь собираются типичные советы по Canvas.


## Базовые критерии

### Б27

:red_circle: - Частота анимации цифр должна быть уменьшена для снижения нагрузки на процессор (критерий Б27).

:point_up: - Критерии оценки - это формальность. Для нас здесь важно научиться ограничивать нагрузку на железо там, где она не нужна. Это одна из важнейших вещей, на которые нужно обращать внимание при работе с анимациями во фронтенде.


## Ситуативные советы


### Про таймер и центр масс

:point_up: - Обратите внимание, что левый край таймера, где цифры почти не меняются, дергается влево-вправо. Такого быть не должно. Если неизменяемый объект в анимации дергается - это всегда режет глаз. Часто можно это сгладить, зафиксировав его положение, и позволив дергаться изменяемым объектам. То же относится и к плавным перемещениям - если какой-то объект является "центром масс" анимации и стоит на месте - он должен стоять на месте, а не колебаться туда-сюда.


## Закрепленные советы


### :lock: 4.01 (про производительность)

:point_up: - Старайтесь всегда уменьшить количество обращений к DOM и перерисовок чего-то на канвасе. Таймерам, разного рода счетчикам, многим визуальным эффектам в большинстве случаев не обязательно дергать реальные элементы на странице 60 раз в секунду. Мы можем каждый кадр проверять, нужно ли обновление, и обновлять реальную страницу только при необходимости. Это уже хорошо скажется на общей производительности. И тут речь идет не только про время и какие-то интервалы, как было в учебнике, но и про любые данные, которые могут нуждаться в обновлении. Данные обновились - обновляем страницу, данные не обновились - ничего не делаем. В учебнике не делается сильного акцента на этом, но на практике лишние обращения к странице могут увеличивать нагрузку на железо в разы, а то и десятки раз.

:point_up: - И сопутствующий момент: запуск и остановка анимаций из скриптов тоже всегда должны быть осознанными действиями. При запуске всегда стоит проверять, не была ли анимация уже запущена, т.к. повторный запуск того же самого увеличивает нагрузку на железо и может приводить к конфликтующим параллельным процессам, а если анимация пропала из области видимости, то ее можно остановить, чтобы не потребляла лишних ресурсов. Возможно вам покажется, что я тут говорю какие-то очевидные вещи, но люди на удивление часто недооценивают их влияние на работу сайтов, поэтому сделать акцент на них будет не лишним.


### :lock: 4.02 (про интерполяцию)

:heavy_plus_sign: - Будет полезно загуглить слово "интерполяция". Даже если вы с понятием уже знакомы (а я надеюсь вы знакомы, а не случайно угадываете подходы к написанию кода), освежить все детали в памяти лишним не будет - эта штука в компьютерной графике применяется на каждом шагу, в том числе и в анимациях. Буквально все JS-библиотеки для анимаций включают в себя интерполяцию значений во времени в том или ином виде, и хорошо понимать, что за всем этим на самом деле скрывается.

:heavy_plus_sign: - По теме будет полезно дополнительно познакомиться с библиотеками [Anime.js](https://animejs.com/) и [GSAP](https://greensock.com/gsap/), и сравнить подходы к организации кода у них, [в Иллюзионе](https://github.com/htmlacademy-animation/illusion/blob/master/source/js/modules/whale-canvas-animation.js), и в [демонстрации с моржом](https://up.htmlacademy.ru/animation/1/demos/5157) в учебнике (это единственная моя демонстрация в курсе). В учебном проекте все нужно делать без использования сторонних библиотек, но для собственного развития - будет хорошо посмотреть на одно и то же с разных сторон, и подумать над тем, как будет удобно организовать работу с разными временными функциями и сопутствующими параметрами в рамках JS.


### :lock: 4.03 (про разные варианты анимирования 2D сцен, производную, вспомогательные построения)

:heavy_plus_sign: - В учебном проекте есть несколько схожих по сути 2D сцен, которые анимируются с помощью CSS, SMIL, а теперь и с помощью скриптов тоже. Будет полезно сравнить эти варианты и подумать, когда будет предпочтительнее тот или иной подход. И не забывайте, что фундаментальные возможности и ограничения часто закладываются и в том, что анимируется, и в том, каким образом оно анимируется. Мы можем анимировать HTML-элементы с помощью скриптов, или SVG с помощью CSS, или, опять же, SVG с помощью скриптов. А еще есть Web Animations API, но это отдельная тема. Возможны разные комбинации со своими особенностями и будет полезно сравнить их, чтобы потом принимать решения при выборе инструментов более осознанно.

:heavy_plus_sign: - Будет полезно загуглить слово "производная". Даже если вы с понятием уже знакомы, освежить все в памяти лишним не будет. Не всегда будет легко угадать, на какой угол должен поворачиваться объект при движении вдоль кривой, заданной какой-то функцией. А задачи такие бывают. Но посчитав производную можно будет найти уравнение касательной к графику функции в текущей точке, а из него по определению получать точный угол поворота объекта. Альтернативно мы можем вычислять значения функции в окрестностях нужной точки на кривой, и по ним получать вектор, параллельный ей. Эти же два подхода активно применяются и в трехмерной графике, в частности в мире WebGL, в сопутствующей задаче поиска нормалей, перпендикуляров к поверхностям, для расчета освещения.

:heavy_plus_sign: - И лайфхак из мира векторных графических редакторов (на случай, если вы еще им не пользуетесь): при работе с кривыми на канвасе может быть полезно делать вспомогательные построения, как [в этом примере](https://codepen.io/sfi0zy/pen/VwKgQPB). Соединять точки, по которым кривые строятся. Так будет гораздо проще понимать, что есть что, и что с чем связано. Особенно это выручает при необходимости составлять длинную кривую из множества коротких. Если вы еще так не делали - самое время попробовать. И графики функций для движений - их тоже можно рисовать на канвасе, вместо того, чтобы пытаться представить их в воображении.


### :lock: 4.04 (про инварианты)

:heavy_plus_sign: - Вы уже достаточно далеко продвинулись по курсу. Самое время начать думать об инвариантах в мире анимаций. Подумайте над тем, что вне зависимости от инструментов и технологий, будь то CSS, SVG, Canvas, какие-то библиотеки ко всему этому, мы так или иначе используем ряд более абстрактных терминов, которые имеют отношение к компьютерной графике в целом. В разных местах они могут называться по-разному, но суть у них одна и та же. Например маски на канвасе, в SVG, или clip-path в CSS - вроде бы это разные вещи, но если подумать - это одно и тоже в сути. С точки зрения конечного рендеринга страницы на экране - это почти одно и то же. [Временные функции](https://habr.com/ru/post/518006/) везде одни и те же. В CSS меньше выбор, чем в JS, но принцип работы тот же. Базовые трансформации - translate, rotate, scale, skew - одинаковые везде и строятся на одних и тех же [преобразованиях координат](https://habr.com/ru/post/520078/). Мы можем их по-разному описывать в коде, но суть решаемых задач от этого не меняется. И так со всем. Более того, вещи, которые плохо влияют на рендеринг страницы, вроде фильтров типа blur, или больших теней, будут одинаково плохо влиять и в CSS, и в SVG, и на канвасе, т.к. их принцип работы в конечном счете крутится вокруг одних и тех же алгоритмов. Подумайте над этим. В перспективе чем больше вы будете таких инвариантов для себя выделять, чем больше вы будете погружаться в базовые алгоритмы и принципы работы вещей, тем проще будет абстрагироваться от конкретных инструментов и решать задачи, которые вы до этого не решали, и предсказывать проблемы, которые еще не видели. Идея выделения инвариантов в предметной области сама по себе не новая, но полезно иногда о ней вспомнить и осмотреть свои знания на предмет наличия чего-то такого.

