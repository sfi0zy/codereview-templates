# Типичные советы по Canvas

Здесь собираются типичные советы по Canvas. Нумерация - в порядке появления. В начале совета - палец или плюс. Советы дополняют ревью, но не являются основанием для отправки задания на доработку, если все работает так, как и должно. Это делается, чтобы не сильно демотивировать студентов - ошибки, описываемые здесь, можно поправить позже (особенно если студент приходит к одному наставнику и есть возможность следить за процессом). Про соответствие базовым критериям см. `4.базовые_критерии`.


### №1 (про таймер и центр масс)

:point_up: - Обратите внимание, что левый край таймера, где цифры почти не меняются, дергается влево-вправо. Такого быть не должно. Это происходит потому, что шрифт не моноширинный. Вероятно текст в таймере нужно выравнивать влево.

:point_up: - Если неизменяемый объект в анимации дергается - это всегда режет глаз. Часто можно это сгладить, зафиксировав его положение, и позволив дергаться изменяемым объектам. То же относится и к плавным перемещениям - если какой-то объект является "центром масс" анимации и стоит на месте - он должен стоять на месте, а не колебаться туда-сюда.


### №2 (связан с критерием оценки Б27)

:point_up: - Критерии оценки - это формальность. Для нас здесь важно научиться ограничивать нагрузку на железо там, где она не нужна. Это одна из важнейших вещей, на которые нужно обращать внимание при работе с анимациями во фронтенде. В контексте задания - старайтесь всегда уменьшить количество обращений к DOM. Таймерам, разного рода счетчикам, галереям картинок с эффектами и.т.д. в большинстве случаев не обязательно дергать реальные элементы на странице 60 раз в секунду.


### №3 (про Anime.js и GSAP)

:heavy_plus_sign: - По теме интерполяции значений в анимациях будет полезно дополнительно познакомиться с библиотеками [Anime.js](https://animejs.com/) и [GSAP](https://greensock.com/gsap/), и сравнить подходы к организации кода у них, в Иллюзионе, и демонстрации с моржом в учебнике. В учебном проекте все нужно делать без использования сторонних библиотек, но для собственного развития - будет полезно.


### №4 (про разные варианты анимирования 2D сцен)

:heavy_plus_sign: - В учебном проекте есть несколько схожих по сути 2D сцен, которые анимируются с помощью CSS, SMIL, а теперь и с помощью скриптов тоже. Будет полезно сравнить эти варианты и подумать, когда будет предпочтительнее тот или иной подход. И не забывайте, что фундаментальные возможности и ограничения часто закладываются и в том, что анимируется, и в том, каким образом оно анимируется. Мы можем анимировать HTML-элементы с помощью скриптов, или SVG с помощью CSS, или, опять же, SVG с помощью скриптов. А еще есть Web Animations API, но это отдельная тема. Возможны разные комбинации со своими особенностями и будет полезно сравнить их, чтобы потом принимать решения при выборе инструментов более осознанно.


### №5 (про инварианты)

:heavy_plus_sign: - Вы уже достаточно далеко продвинулись по курсу. Самое время начать думать об инвариантах в мире анимаций. Подумайте над тем, что вне зависимости от инструментов и технологий, будь то CSS, SVG, Canvas, какие-то библиотеки ко всему этому, мы так или иначе используем ряд более абстрактных терминов, которые имеют отношение к компьютерной графике в целом. В разных местах они могут называться по-разному, но суть у них одна и та же. Например маски на канвасе, в SVG, или clip-path в CSS - вроде бы это разные вещи, но если подумать - это одно и тоже в сути. С точки зрения конечного рендеринга страницы на экране - это почти одно и то же. [Временные функции](https://habr.com/ru/post/518006/) везде одни и те же (в CSS меньше выбор, чем в JS, но принцип работы тот же). Базовые трансформации - translate, rotate, scale, skew - одинаковые везде и строятся на одних и тех же [преобразованиях координат](https://habr.com/ru/post/520078/). Мы можем их по-разному описывать в коде, но суть от этого не меняется. И так со всем. Более того, вещи, которые плохо влияют на рендеринг страницы, вроде фильтров типа blur, или больших теней, будут одинаково плохо влиять и в CSS, и в SVG, и на канвасе, т.к. их принцип работы в конечном счете крутится вокруг одних и тех же алгоритмов. Подумайте над этим. В перспективе чем больше вы будете таких инвариантов для себя выделять, чем больше вы будете погружаться в базовые алгоритмы и принципы работы вещей, тем проще будет абстрагироваться от конкретных инструментов и решать задачи, которые вы до этого не решали. Идея эта не новая, но полезно иногда о ней вспомнить и осмотреть новые знания на предмет наличия чего-то такого.


### №6 (про интерполяцию)

:heavy_plus_sign: - Будет полезно загуглить слово "интерполяция". Даже если вы с понятием уже знакомы, освежить все в памяти лишним не будет - эта штука в компьютерной графике применяется на каждом шагу. В контексте задания - заготовка значений заранее не всегда нужна (а для геометрических движений почти никогда не нужна). Например здесь - обычная линейная интерполяция значений во времени позволяет на ходу получать значения чисел для любого количества кадров, а не только фиксированного. Получается более гибкое решение по сравнению с заготовленными кадрами. А можно было бы сделать ее не линейной и замедлять счет или ускорять, при этом сохраняя понятное зрителю распределение чисел (например при замедлении числа к концу менялись бы на все меньшие значения). Более развернутый пример есть в моей демонстрации с моржом в учебнике (аналогичная мини-библиотека для интерполяций лежит в репозитории [weeee.js](https://github.com/sfi0zy/weeee)), будет полезно один из этих примеров проанализировать и разобраться, как там все работает.


### №7 (про производную)

:heavy_plus_sign: - Будет полезно загуглить слово "производная". Даже если вы с понятием уже знакомы, освежить все в памяти лишним не будет. Не всегда будет легко угадать, на какой угол должен поворачиваться объект при движении вдоль кривой, заданной какой-то функцией (или системой, если речь про параметрические функции). Но посчитав производные можно будет найти уравнение касательной к графику функции в текущей точке, и подставляя одно и то же время в это уравнение и в исходное уравнение - получать точный угол поворота объекта в каждый момент движения.


### №8 (про вспомогательные построения)

:heavy_plus_sign: - Лайфхак из мира векторных графических редакторов: при работе с кривыми на канвасе (да и не только на канвасе) может быть полезно делать вспомогательные построения, как [в этом примере](https://codepen.io/sfi0zy/pen/VwKgQPB), соединять точки, по которым кривые строятся. Так будет гораздо проще понимать, что есть что, и что с чем связано. Особенно это выручает при необходимости составлять длинную кривую из множества коротких. Если вы еще так не делали - самое время попробовать. И графики функций - их тоже можно рисовать на канвасе, вместо того, чтобы пытаться представить их в голове.

